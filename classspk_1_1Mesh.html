<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparkle: spk::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sparkle
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacespk.html">spk</a></li><li class="navelem"><a class="el" href="classspk_1_1Mesh.html">Mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classspk_1_1Mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">spk::Mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a mesh in the Sparkle engine.  
 <a href="classspk_1_1Mesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="spk__mesh_8hpp_source.html">spk_mesh.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for spk::Mesh:</div>
<div class="dyncontent">
<div class="center"><img src="classspk_1_1Mesh__inherit__graph.png" border="0" usemap="#aspk_1_1Mesh_inherit__map" alt="Inheritance graph"/></div>
<map name="aspk_1_1Mesh_inherit__map" id="aspk_1_1Mesh_inherit__map">
<area shape="rect" title="Represents a mesh in the Sparkle engine." alt="" coords="5,5,93,32"/>
<area shape="rect" href="classspk_1_1Cube.html" title="Represents a cube mesh in the Sparkle engine." alt="" coords="6,80,93,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1Mesh_1_1Vertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a vertex in the mesh. A <a class="el" href="structspk_1_1Mesh_1_1Vertex.html" title="Structure representing a vertex in the mesh. A Vertex is a representation of 3 variables linked toget...">Vertex</a> is a representation of 3 variables linked together :  <a href="structspk_1_1Mesh_1_1Vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a08041de6df6465e8b8a83e2b86c9c7f8"><td class="memItemLeft" align="right" valign="top"><a id="a08041de6df6465e8b8a83e2b86c9c7f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#a08041de6df6465e8b8a83e2b86c9c7f8">Mesh</a> ()</td></tr>
<tr class="memdesc:a08041de6df6465e8b8a83e2b86c9c7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classspk_1_1Mesh.html" title="Represents a mesh in the Sparkle engine.">Mesh</a> object. <br /></td></tr>
<tr class="separator:a08041de6df6465e8b8a83e2b86c9c7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc98bfa2094d70c2889e9eda28f6801"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacespk.html#a25ce29c89e3ca14bf467a94db03d5939">spk::Vector3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#accc98bfa2094d70c2889e9eda28f6801">points</a> ()</td></tr>
<tr class="memdesc:accc98bfa2094d70c2889e9eda28f6801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the mutable points in the mesh.  <a href="classspk_1_1Mesh.html#accc98bfa2094d70c2889e9eda28f6801">More...</a><br /></td></tr>
<tr class="separator:accc98bfa2094d70c2889e9eda28f6801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3150e8448c719c1bb35cc0dcf87c8261"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacespk.html#a25ce29c89e3ca14bf467a94db03d5939">spk::Vector3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#a3150e8448c719c1bb35cc0dcf87c8261">points</a> () const</td></tr>
<tr class="memdesc:a3150e8448c719c1bb35cc0dcf87c8261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the immutable points in the mesh.  <a href="classspk_1_1Mesh.html#a3150e8448c719c1bb35cc0dcf87c8261">More...</a><br /></td></tr>
<tr class="separator:a3150e8448c719c1bb35cc0dcf87c8261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465494613cd39c2df2ed09e854054982"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacespk.html#a9b7d33188f36fb94cdde3264ccc16e20">spk::Vector2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#a465494613cd39c2df2ed09e854054982">uvs</a> ()</td></tr>
<tr class="memdesc:a465494613cd39c2df2ed09e854054982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the mutable UV coordinates in the mesh.  <a href="classspk_1_1Mesh.html#a465494613cd39c2df2ed09e854054982">More...</a><br /></td></tr>
<tr class="separator:a465494613cd39c2df2ed09e854054982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c54378a9343acfb18635467a05fa7e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacespk.html#a9b7d33188f36fb94cdde3264ccc16e20">spk::Vector2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#af0c54378a9343acfb18635467a05fa7e">uvs</a> () const</td></tr>
<tr class="memdesc:af0c54378a9343acfb18635467a05fa7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the immutable UV coordinates in the mesh.  <a href="classspk_1_1Mesh.html#af0c54378a9343acfb18635467a05fa7e">More...</a><br /></td></tr>
<tr class="separator:af0c54378a9343acfb18635467a05fa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca41a573521f39c089e5d156fa29dec1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacespk.html#a25ce29c89e3ca14bf467a94db03d5939">spk::Vector3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#aca41a573521f39c089e5d156fa29dec1">normals</a> ()</td></tr>
<tr class="memdesc:aca41a573521f39c089e5d156fa29dec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the mutable normals in the mesh.  <a href="classspk_1_1Mesh.html#aca41a573521f39c089e5d156fa29dec1">More...</a><br /></td></tr>
<tr class="separator:aca41a573521f39c089e5d156fa29dec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2651226890af9a5b543b5a7c932b8817"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacespk.html#a25ce29c89e3ca14bf467a94db03d5939">spk::Vector3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#a2651226890af9a5b543b5a7c932b8817">normals</a> () const</td></tr>
<tr class="memdesc:a2651226890af9a5b543b5a7c932b8817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the immutable normals in the mesh.  <a href="classspk_1_1Mesh.html#a2651226890af9a5b543b5a7c932b8817">More...</a><br /></td></tr>
<tr class="separator:a2651226890af9a5b543b5a7c932b8817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d063f734d55a9bfea30d3749cee9391"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structspk_1_1Mesh_1_1Vertex.html">Vertex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#a8d063f734d55a9bfea30d3749cee9391">vertices</a> () const</td></tr>
<tr class="memdesc:a8d063f734d55a9bfea30d3749cee9391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the immutable vertices in the mesh.  <a href="classspk_1_1Mesh.html#a8d063f734d55a9bfea30d3749cee9391">More...</a><br /></td></tr>
<tr class="separator:a8d063f734d55a9bfea30d3749cee9391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19fc0cd6344598b6e9d9ddee8781e58"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#ac19fc0cd6344598b6e9d9ddee8781e58">indexes</a> () const</td></tr>
<tr class="memdesc:ac19fc0cd6344598b6e9d9ddee8781e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the immutable indices in the mesh.  <a href="classspk_1_1Mesh.html#ac19fc0cd6344598b6e9d9ddee8781e58">More...</a><br /></td></tr>
<tr class="separator:ac19fc0cd6344598b6e9d9ddee8781e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0be9b7ffaf7afe7a40c8fc3f513d9a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#ad0be9b7ffaf7afe7a40c8fc3f513d9a7">addVertex</a> (const size_t &amp;p_pointIndex, const size_t &amp;p_uvIndex, const size_t &amp;p_normalIndex)</td></tr>
<tr class="memdesc:ad0be9b7ffaf7afe7a40c8fc3f513d9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the mesh.  <a href="classspk_1_1Mesh.html#ad0be9b7ffaf7afe7a40c8fc3f513d9a7">More...</a><br /></td></tr>
<tr class="separator:ad0be9b7ffaf7afe7a40c8fc3f513d9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ade7d02b6bae578f7b422bbdabf4d48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#a5ade7d02b6bae578f7b422bbdabf4d48">addFace</a> (const unsigned int &amp;p_vertexIndexA, const unsigned int &amp;p_vertexIndexB, const unsigned int &amp;p_vertexIndexC)</td></tr>
<tr class="memdesc:a5ade7d02b6bae578f7b422bbdabf4d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a triangular face to the mesh.  <a href="classspk_1_1Mesh.html#a5ade7d02b6bae578f7b422bbdabf4d48">More...</a><br /></td></tr>
<tr class="separator:a5ade7d02b6bae578f7b422bbdabf4d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3f793bbfb0ebcc5bd982922b6066a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#aea3f793bbfb0ebcc5bd982922b6066a8">addFace</a> (const unsigned int &amp;p_vertexIndexA, const unsigned int &amp;p_vertexIndexB, const unsigned int &amp;p_vertexIndexC, const unsigned int &amp;p_vertexIndexD)</td></tr>
<tr class="memdesc:aea3f793bbfb0ebcc5bd982922b6066a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a quadrilateral face to the mesh.  <a href="classspk_1_1Mesh.html#aea3f793bbfb0ebcc5bd982922b6066a8">More...</a><br /></td></tr>
<tr class="separator:aea3f793bbfb0ebcc5bd982922b6066a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3c1ed09f5275c82dce7f8341ddd364"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#a2a3c1ed09f5275c82dce7f8341ddd364">needUpdate</a> () const</td></tr>
<tr class="memdesc:a2a3c1ed09f5275c82dce7f8341ddd364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the mesh needs to be updated.  <a href="classspk_1_1Mesh.html#a2a3c1ed09f5275c82dce7f8341ddd364">More...</a><br /></td></tr>
<tr class="separator:a2a3c1ed09f5275c82dce7f8341ddd364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd6b6c2a1a13f209b2c0906911324bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#a6bd6b6c2a1a13f209b2c0906911324bd">setNeedUpdateFlag</a> (bool p_state)</td></tr>
<tr class="memdesc:a6bd6b6c2a1a13f209b2c0906911324bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the flag that indicates whether the mesh needs an update.  <a href="classspk_1_1Mesh.html#a6bd6b6c2a1a13f209b2c0906911324bd">More...</a><br /></td></tr>
<tr class="separator:a6bd6b6c2a1a13f209b2c0906911324bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b82915aaa5eaa58acad404285e6aee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html#aa3b82915aaa5eaa58acad404285e6aee">resetNeedUpdateFlag</a> ()</td></tr>
<tr class="memdesc:aa3b82915aaa5eaa58acad404285e6aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the update flag for the mesh.  <a href="classspk_1_1Mesh.html#aa3b82915aaa5eaa58acad404285e6aee">More...</a><br /></td></tr>
<tr class="separator:aa3b82915aaa5eaa58acad404285e6aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a mesh in the Sparkle engine. </p>
<p>A mesh is composed of points in 3D, normals, UV coordinates, and indices that define the shape and appearance of a 3D object. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5ade7d02b6bae578f7b422bbdabf4d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ade7d02b6bae578f7b422bbdabf4d48">&#9670;&nbsp;</a></span>addFace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::Mesh::addFace </td>
          <td>(</td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>p_vertexIndexA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>p_vertexIndexB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>p_vertexIndexC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a triangular face to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_vertexIndexA</td><td>Index of the first vertex of the triangle. </td></tr>
    <tr><td class="paramname">p_vertexIndexB</td><td>Index of the second vertex of the triangle. </td></tr>
    <tr><td class="paramname">p_vertexIndexC</td><td>Index of the third vertex of the triangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea3f793bbfb0ebcc5bd982922b6066a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3f793bbfb0ebcc5bd982922b6066a8">&#9670;&nbsp;</a></span>addFace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::Mesh::addFace </td>
          <td>(</td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>p_vertexIndexA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>p_vertexIndexB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>p_vertexIndexC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>p_vertexIndexD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a quadrilateral face to the mesh. </p>
<p>Describes the topology for a face on the mesh, specifying the vertices in clockwise or counterclockwise order.</p>
<p>Top side view exemple : Z | A B | <em>--&mdash;</em> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>| <em>--&mdash;</em> | D C | o------------&mdash;X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_vertexIndexA</td><td>Index of the first vertex of the quadrilateral. </td></tr>
    <tr><td class="paramname">p_vertexIndexB</td><td>Index of the second vertex of the quadrilateral. </td></tr>
    <tr><td class="paramname">p_vertexIndexC</td><td>Index of the third vertex of the quadrilateral. </td></tr>
    <tr><td class="paramname">p_vertexIndexD</td><td>Index of the fourth vertex of the quadrilateral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0be9b7ffaf7afe7a40c8fc3f513d9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0be9b7ffaf7afe7a40c8fc3f513d9a7">&#9670;&nbsp;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::Mesh::addVertex </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>p_pointIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>p_uvIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>p_normalIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_pointIndex</td><td>Index of the point in the mesh. </td></tr>
    <tr><td class="paramname">p_uvIndex</td><td>Index of the UV coordinate in the mesh. </td></tr>
    <tr><td class="paramname">p_normalIndex</td><td>Index of the normal in the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac19fc0cd6344598b6e9d9ddee8781e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19fc0cd6344598b6e9d9ddee8781e58">&#9670;&nbsp;</a></span>indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned int &gt; spk::Mesh::indexes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the immutable indices in the mesh. </p>
<p>This method returns a constant reference to the vector of indices. These indices define the order in which vertices are connected to form the faces of the mesh. This method is primarily used in rendering to draw the mesh correctly.</p>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned int&gt;&amp; Constant reference to the vector of indices. </dd></dl>

</div>
</div>
<a id="a2a3c1ed09f5275c82dce7f8341ddd364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3c1ed09f5275c82dce7f8341ddd364">&#9670;&nbsp;</a></span>needUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spk::Mesh::needUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the mesh needs to be updated. </p>
<p>This method is used to determine whether the mesh data has changed and needs to be updated, for example, in the graphics pipeline.</p>
<dl class="section return"><dt>Returns</dt><dd>bool True if the mesh needs an update, false otherwise. </dd></dl>

</div>
</div>
<a id="aca41a573521f39c089e5d156fa29dec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca41a573521f39c089e5d156fa29dec1">&#9670;&nbsp;</a></span>normals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacespk.html#a25ce29c89e3ca14bf467a94db03d5939">spk::Vector3</a> &gt; &amp; spk::Mesh::normals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the mutable normals in the mesh. </p>
<p>This method returns a reference to the vector of normals. Normals are essential for lighting calculations in 3D rendering. Modifying this vector allows for dynamic changes to how the mesh interacts with light.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;spk::Vector3&gt;&amp; Reference to the vector of normals. </dd></dl>

</div>
</div>
<a id="a2651226890af9a5b543b5a7c932b8817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2651226890af9a5b543b5a7c932b8817">&#9670;&nbsp;</a></span>normals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="namespacespk.html#a25ce29c89e3ca14bf467a94db03d5939">spk::Vector3</a> &gt; &amp; spk::Mesh::normals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the immutable normals in the mesh. </p>
<p>This method returns a constant reference to the vector of normals, which is used in lighting calculations during rendering. It allows for read-only access to the normals, ensuring they are not inadvertently modified.</p>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;spk::Vector3&gt;&amp; Constant reference to the vector of normals. </dd></dl>

</div>
</div>
<a id="accc98bfa2094d70c2889e9eda28f6801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc98bfa2094d70c2889e9eda28f6801">&#9670;&nbsp;</a></span>points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacespk.html#a25ce29c89e3ca14bf467a94db03d5939">spk::Vector3</a> &gt; &amp; spk::Mesh::points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the mutable points in the mesh. </p>
<p>This method returns a reference to the vector of 3D points that make up the mesh. It allows for direct modification of the mesh's points, which can be used for dynamic mesh manipulation.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;spk::Vector3&gt;&amp; Reference to the vector of 3D points. </dd></dl>

</div>
</div>
<a id="a3150e8448c719c1bb35cc0dcf87c8261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3150e8448c719c1bb35cc0dcf87c8261">&#9670;&nbsp;</a></span>points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="namespacespk.html#a25ce29c89e3ca14bf467a94db03d5939">spk::Vector3</a> &gt; &amp; spk::Mesh::points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the immutable points in the mesh. </p>
<p>This method returns a constant reference to the vector of 3D points. It is used for accessing the points without modifying them, typically for read-only operations such as rendering.</p>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;spk::Vector3&gt;&amp; Constant reference to the vector of 3D points. </dd></dl>

</div>
</div>
<a id="aa3b82915aaa5eaa58acad404285e6aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b82915aaa5eaa58acad404285e6aee">&#9670;&nbsp;</a></span>resetNeedUpdateFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::Mesh::resetNeedUpdateFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the update flag for the mesh. </p>
<p>This method is used to reset the update flag, indicating that the mesh has been updated and no further updates are currently needed. </p>

</div>
</div>
<a id="a6bd6b6c2a1a13f209b2c0906911324bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd6b6c2a1a13f209b2c0906911324bd">&#9670;&nbsp;</a></span>setNeedUpdateFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::Mesh::setNeedUpdateFlag </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>p_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the flag that indicates whether the mesh needs an update. </p>
<p>This method allows setting the state of the update flag, which can be used to trigger an update of the mesh data when required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_state</td><td>The state to set for the update flag (true or false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a465494613cd39c2df2ed09e854054982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465494613cd39c2df2ed09e854054982">&#9670;&nbsp;</a></span>uvs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacespk.html#a9b7d33188f36fb94cdde3264ccc16e20">spk::Vector2</a> &gt; &amp; spk::Mesh::uvs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the mutable UV coordinates in the mesh. </p>
<p>This method returns a reference to the vector of UV coordinates used for texture mapping. It allows for direct modification of the UVs, useful for changing how textures are applied to the mesh.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;spk::Vector2&gt;&amp; Reference to the vector of UV coordinates. </dd></dl>

</div>
</div>
<a id="af0c54378a9343acfb18635467a05fa7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c54378a9343acfb18635467a05fa7e">&#9670;&nbsp;</a></span>uvs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="namespacespk.html#a9b7d33188f36fb94cdde3264ccc16e20">spk::Vector2</a> &gt; &amp; spk::Mesh::uvs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the immutable UV coordinates in the mesh. </p>
<p>This method returns a constant reference to the vector of UV coordinates. It is used for accessing the UVs without modifying them, typically in texture mapping during rendering.</p>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;spk::Vector2&gt;&amp; Constant reference to the vector of UV coordinates. </dd></dl>

</div>
</div>
<a id="a8d063f734d55a9bfea30d3749cee9391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d063f734d55a9bfea30d3749cee9391">&#9670;&nbsp;</a></span>vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="structspk_1_1Mesh_1_1Vertex.html">Mesh::Vertex</a> &gt; &amp; spk::Mesh::vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the immutable vertices in the mesh. </p>
<p>This method returns a constant reference to the vector of vertices. Each vertex in the vector contains position, UV, and normal data. This method is typically used for read-only operations such as rendering.</p>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;Vertex&gt;&amp; Constant reference to the vector of vertices. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Sparkle/includes/engine/<a class="el" href="spk__mesh_8hpp_source.html">spk_mesh.hpp</a></li>
<li>Sparkle/src/engine/spk_mesh.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
