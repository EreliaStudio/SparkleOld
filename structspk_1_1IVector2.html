<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparkle: spk::IVector2&lt; TType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sparkle
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacespk.html">spk</a></li><li class="navelem"><a class="el" href="structspk_1_1IVector2.html">IVector2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structspk_1_1IVector2-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">spk::IVector2&lt; TType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A two-dimensional vector class with variable type.  
 <a href="structspk_1_1IVector2.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="spk__vector2_8hpp_source.html">spk_vector2.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad681cb3d88fd9a4ca1e60c3c44e600b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#ad681cb3d88fd9a4ca1e60c3c44e600b6">IVector2</a> ()</td></tr>
<tr class="memdesc:ad681cb3d88fd9a4ca1e60c3c44e600b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="structspk_1_1IVector2.html#ad681cb3d88fd9a4ca1e60c3c44e600b6">More...</a><br /></td></tr>
<tr class="separator:ad681cb3d88fd9a4ca1e60c3c44e600b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae197d470bdc2579bd6434f1d23e569bc"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:ae197d470bdc2579bd6434f1d23e569bc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#ae197d470bdc2579bd6434f1d23e569bc">IVector2</a> (const TOtherType &amp;p_value)</td></tr>
<tr class="memdesc:ae197d470bdc2579bd6434f1d23e569bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that initializes both coordinates with a single value.  <a href="structspk_1_1IVector2.html#ae197d470bdc2579bd6434f1d23e569bc">More...</a><br /></td></tr>
<tr class="separator:ae197d470bdc2579bd6434f1d23e569bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3199f7709d8d15633920c7602b1c1e55"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a3199f7709d8d15633920c7602b1c1e55"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a3199f7709d8d15633920c7602b1c1e55">IVector2</a> (const TOtherType &amp;p_x, const TOtherType &amp;p_y)</td></tr>
<tr class="memdesc:a3199f7709d8d15633920c7602b1c1e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that initializes the vector with two values.  <a href="structspk_1_1IVector2.html#a3199f7709d8d15633920c7602b1c1e55">More...</a><br /></td></tr>
<tr class="separator:a3199f7709d8d15633920c7602b1c1e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4960cc3b4ade5cfd48cd0b78281d179a"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a4960cc3b4ade5cfd48cd0b78281d179a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a4960cc3b4ade5cfd48cd0b78281d179a">operator IVector2&lt; TOtherType &gt;</a> ()</td></tr>
<tr class="memdesc:a4960cc3b4ade5cfd48cd0b78281d179a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-casting operator.  <a href="structspk_1_1IVector2.html#a4960cc3b4ade5cfd48cd0b78281d179a">More...</a><br /></td></tr>
<tr class="separator:a4960cc3b4ade5cfd48cd0b78281d179a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6df11d0dea89825de285227208b4e8"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a9d6df11d0dea89825de285227208b4e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a9d6df11d0dea89825de285227208b4e8">operator+</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other) const</td></tr>
<tr class="memdesc:a9d6df11d0dea89825de285227208b4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of + operator.  <a href="structspk_1_1IVector2.html#a9d6df11d0dea89825de285227208b4e8">More...</a><br /></td></tr>
<tr class="separator:a9d6df11d0dea89825de285227208b4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93181e2a39090202e764fe87e5a6d1c5"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a93181e2a39090202e764fe87e5a6d1c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a93181e2a39090202e764fe87e5a6d1c5">operator-</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other) const</td></tr>
<tr class="memdesc:a93181e2a39090202e764fe87e5a6d1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of - operator.  <a href="structspk_1_1IVector2.html#a93181e2a39090202e764fe87e5a6d1c5">More...</a><br /></td></tr>
<tr class="separator:a93181e2a39090202e764fe87e5a6d1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409c7ef14a15f0e7bee9e781ea3f029c"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a409c7ef14a15f0e7bee9e781ea3f029c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a409c7ef14a15f0e7bee9e781ea3f029c">operator*</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other) const</td></tr>
<tr class="memdesc:a409c7ef14a15f0e7bee9e781ea3f029c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of * operator.  <a href="structspk_1_1IVector2.html#a409c7ef14a15f0e7bee9e781ea3f029c">More...</a><br /></td></tr>
<tr class="separator:a409c7ef14a15f0e7bee9e781ea3f029c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8fac9e93e024514717ef2594724aec"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a7d8fac9e93e024514717ef2594724aec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a7d8fac9e93e024514717ef2594724aec">operator/</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other) const</td></tr>
<tr class="memdesc:a7d8fac9e93e024514717ef2594724aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of / operator.  <a href="structspk_1_1IVector2.html#a7d8fac9e93e024514717ef2594724aec">More...</a><br /></td></tr>
<tr class="separator:a7d8fac9e93e024514717ef2594724aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f20fbffbe8c392bf857f84f6175c33"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a46f20fbffbe8c392bf857f84f6175c33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a46f20fbffbe8c392bf857f84f6175c33">operator+=</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other)</td></tr>
<tr class="memdesc:a46f20fbffbe8c392bf857f84f6175c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of += operator.  <a href="structspk_1_1IVector2.html#a46f20fbffbe8c392bf857f84f6175c33">More...</a><br /></td></tr>
<tr class="separator:a46f20fbffbe8c392bf857f84f6175c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c33ee627ed1700aff6627261a074ac"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a96c33ee627ed1700aff6627261a074ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a96c33ee627ed1700aff6627261a074ac">operator-=</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other)</td></tr>
<tr class="memdesc:a96c33ee627ed1700aff6627261a074ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of -= operator.  <a href="structspk_1_1IVector2.html#a96c33ee627ed1700aff6627261a074ac">More...</a><br /></td></tr>
<tr class="separator:a96c33ee627ed1700aff6627261a074ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0609e1b115b35f3293a19e9f1b3aa91c"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a0609e1b115b35f3293a19e9f1b3aa91c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a0609e1b115b35f3293a19e9f1b3aa91c">operator*=</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other)</td></tr>
<tr class="memdesc:a0609e1b115b35f3293a19e9f1b3aa91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of *= operator.  <a href="structspk_1_1IVector2.html#a0609e1b115b35f3293a19e9f1b3aa91c">More...</a><br /></td></tr>
<tr class="separator:a0609e1b115b35f3293a19e9f1b3aa91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8158dcf13f51999650b00e83c36be525"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a8158dcf13f51999650b00e83c36be525"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a8158dcf13f51999650b00e83c36be525">operator/=</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other)</td></tr>
<tr class="memdesc:a8158dcf13f51999650b00e83c36be525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of /= operator.  <a href="structspk_1_1IVector2.html#a8158dcf13f51999650b00e83c36be525">More...</a><br /></td></tr>
<tr class="separator:a8158dcf13f51999650b00e83c36be525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a45be30c1cb18600add47dddd15ce1"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a19a45be30c1cb18600add47dddd15ce1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a19a45be30c1cb18600add47dddd15ce1">operator==</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;delta) const</td></tr>
<tr class="memdesc:a19a45be30c1cb18600add47dddd15ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of == operator.  <a href="structspk_1_1IVector2.html#a19a45be30c1cb18600add47dddd15ce1">More...</a><br /></td></tr>
<tr class="separator:a19a45be30c1cb18600add47dddd15ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d7e368595e4a4db1580995d7df6f6"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a8a7d7e368595e4a4db1580995d7df6f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a8a7d7e368595e4a4db1580995d7df6f6">operator!=</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;delta) const</td></tr>
<tr class="memdesc:a8a7d7e368595e4a4db1580995d7df6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of != operator.  <a href="structspk_1_1IVector2.html#a8a7d7e368595e4a4db1580995d7df6f6">More...</a><br /></td></tr>
<tr class="separator:a8a7d7e368595e4a4db1580995d7df6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ee09f391a89938f95501f6f830818d"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a50ee09f391a89938f95501f6f830818d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a50ee09f391a89938f95501f6f830818d">operator&lt;</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other) const</td></tr>
<tr class="memdesc:a50ee09f391a89938f95501f6f830818d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of &lt; operator.  <a href="structspk_1_1IVector2.html#a50ee09f391a89938f95501f6f830818d">More...</a><br /></td></tr>
<tr class="separator:a50ee09f391a89938f95501f6f830818d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b6a3babc24fbb384fde2327590f4ef"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:ab1b6a3babc24fbb384fde2327590f4ef"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#ab1b6a3babc24fbb384fde2327590f4ef">operator&gt;</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other) const</td></tr>
<tr class="memdesc:ab1b6a3babc24fbb384fde2327590f4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of &gt; operator.  <a href="structspk_1_1IVector2.html#ab1b6a3babc24fbb384fde2327590f4ef">More...</a><br /></td></tr>
<tr class="separator:ab1b6a3babc24fbb384fde2327590f4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1604ed3d5d9945e9183396dc976d906"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:ae1604ed3d5d9945e9183396dc976d906"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#ae1604ed3d5d9945e9183396dc976d906">operator&lt;=</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other) const</td></tr>
<tr class="memdesc:ae1604ed3d5d9945e9183396dc976d906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of &lt;= operator.  <a href="structspk_1_1IVector2.html#ae1604ed3d5d9945e9183396dc976d906">More...</a><br /></td></tr>
<tr class="separator:ae1604ed3d5d9945e9183396dc976d906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd97e47a3bfd966a412f9520c98748d1"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:acd97e47a3bfd966a412f9520c98748d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#acd97e47a3bfd966a412f9520c98748d1">operator&gt;=</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other) const</td></tr>
<tr class="memdesc:acd97e47a3bfd966a412f9520c98748d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of &gt;= operator.  <a href="structspk_1_1IVector2.html#acd97e47a3bfd966a412f9520c98748d1">More...</a><br /></td></tr>
<tr class="separator:acd97e47a3bfd966a412f9520c98748d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d0c755988c4ce9ec8e86e1744d997e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#aa0d0c755988c4ce9ec8e86e1744d997e">norm</a> () const</td></tr>
<tr class="memdesc:aa0d0c755988c4ce9ec8e86e1744d997e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the norm (or length) of this vector.  <a href="structspk_1_1IVector2.html#aa0d0c755988c4ce9ec8e86e1744d997e">More...</a><br /></td></tr>
<tr class="separator:aa0d0c755988c4ce9ec8e86e1744d997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3cb20ecff4c986f8a7d602e89623a2"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:abf3cb20ecff4c986f8a7d602e89623a2"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#abf3cb20ecff4c986f8a7d602e89623a2">distance</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other) const</td></tr>
<tr class="memdesc:abf3cb20ecff4c986f8a7d602e89623a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Euclidean distance between this vector and another vector.  <a href="structspk_1_1IVector2.html#abf3cb20ecff4c986f8a7d602e89623a2">More...</a><br /></td></tr>
<tr class="separator:abf3cb20ecff4c986f8a7d602e89623a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc80581ee0fb7ce5f10b751b85fa0cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a6bc80581ee0fb7ce5f10b751b85fa0cb">normalize</a> () const</td></tr>
<tr class="memdesc:a6bc80581ee0fb7ce5f10b751b85fa0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes this vector.  <a href="structspk_1_1IVector2.html#a6bc80581ee0fb7ce5f10b751b85fa0cb">More...</a><br /></td></tr>
<tr class="separator:a6bc80581ee0fb7ce5f10b751b85fa0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5cc1aceeca9b90fcecf6d6fe49520d"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a4d5cc1aceeca9b90fcecf6d6fe49520d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a4d5cc1aceeca9b90fcecf6d6fe49520d">cross</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other=<a class="el" href="structspk_1_1IVector2.html">IVector2</a>(0, 0)) const</td></tr>
<tr class="memdesc:a4d5cc1aceeca9b90fcecf6d6fe49520d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the 2D cross product with another vector.  <a href="structspk_1_1IVector2.html#a4d5cc1aceeca9b90fcecf6d6fe49520d">More...</a><br /></td></tr>
<tr class="separator:a4d5cc1aceeca9b90fcecf6d6fe49520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab6d332aa26f3da116169b39014f113"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a6ab6d332aa26f3da116169b39014f113"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a6ab6d332aa26f3da116169b39014f113">crossZ</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other) const</td></tr>
<tr class="memdesc:a6ab6d332aa26f3da116169b39014f113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the z-component of the cross product with another vector.  <a href="structspk_1_1IVector2.html#a6ab6d332aa26f3da116169b39014f113">More...</a><br /></td></tr>
<tr class="separator:a6ab6d332aa26f3da116169b39014f113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b615184fb3c906955819e01958102bc"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a5b615184fb3c906955819e01958102bc"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a5b615184fb3c906955819e01958102bc">dot</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_center=<a class="el" href="structspk_1_1IVector2.html">IVector2</a>(0, 0)) const</td></tr>
<tr class="memdesc:a5b615184fb3c906955819e01958102bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dot product with another vector, with respect to a center vector.  <a href="structspk_1_1IVector2.html#a5b615184fb3c906955819e01958102bc">More...</a><br /></td></tr>
<tr class="separator:a5b615184fb3c906955819e01958102bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3925ad849ad4d9b1bdba9a8c0d879c"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a4c3925ad849ad4d9b1bdba9a8c0d879c"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a4c3925ad849ad4d9b1bdba9a8c0d879c">angle</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_other, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_center=<a class="el" href="structspk_1_1IVector2.html">IVector2</a>(0, 0)) const</td></tr>
<tr class="memdesc:a4c3925ad849ad4d9b1bdba9a8c0d879c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the angle between this vector and another vector, with respect to a center vector.  <a href="structspk_1_1IVector2.html#a4c3925ad849ad4d9b1bdba9a8c0d879c">More...</a><br /></td></tr>
<tr class="separator:a4c3925ad849ad4d9b1bdba9a8c0d879c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bb60fe03d90225da1337147ac4bb72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a94bb60fe03d90225da1337147ac4bb72">invert</a> () const</td></tr>
<tr class="memdesc:a94bb60fe03d90225da1337147ac4bb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts this vector.  <a href="structspk_1_1IVector2.html#a94bb60fe03d90225da1337147ac4bb72">More...</a><br /></td></tr>
<tr class="separator:a94bb60fe03d90225da1337147ac4bb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a657d838bdfcbb18dd0309977d34d5b"><td class="memTemplParams" colspan="2">template&lt;typename TOtherType &gt; </td></tr>
<tr class="memitem:a2a657d838bdfcbb18dd0309977d34d5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a2a657d838bdfcbb18dd0309977d34d5b">rotate</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;p_center, const float &amp;p_angle) const</td></tr>
<tr class="memdesc:a2a657d838bdfcbb18dd0309977d34d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates this vector around a given center point.  <a href="structspk_1_1IVector2.html#a2a657d838bdfcbb18dd0309977d34d5b">More...</a><br /></td></tr>
<tr class="separator:a2a657d838bdfcbb18dd0309977d34d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af58b4937f57ec150690b653144e627f2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#af58b4937f57ec150690b653144e627f2">floor</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_vector)</td></tr>
<tr class="memdesc:af58b4937f57ec150690b653144e627f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds down the coordinates of a vector.  <a href="structspk_1_1IVector2.html#af58b4937f57ec150690b653144e627f2">More...</a><br /></td></tr>
<tr class="separator:af58b4937f57ec150690b653144e627f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22c9a8609ce9b7f2215eff7c120ed0c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#ac22c9a8609ce9b7f2215eff7c120ed0c">ceiling</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_vector)</td></tr>
<tr class="memdesc:ac22c9a8609ce9b7f2215eff7c120ed0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up the coordinates of a vector.  <a href="structspk_1_1IVector2.html#ac22c9a8609ce9b7f2215eff7c120ed0c">More...</a><br /></td></tr>
<tr class="separator:ac22c9a8609ce9b7f2215eff7c120ed0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173f7d72b11d82a87db01e6a6dfe625e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a173f7d72b11d82a87db01e6a6dfe625e">round</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_vector)</td></tr>
<tr class="memdesc:a173f7d72b11d82a87db01e6a6dfe625e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the coordinates of a vector to the nearest integer.  <a href="structspk_1_1IVector2.html#a173f7d72b11d82a87db01e6a6dfe625e">More...</a><br /></td></tr>
<tr class="separator:a173f7d72b11d82a87db01e6a6dfe625e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64ebb9cf02e5bbf329ea31d35e29841"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#ae64ebb9cf02e5bbf329ea31d35e29841">min</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_min, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_max)</td></tr>
<tr class="memdesc:ae64ebb9cf02e5bbf329ea31d35e29841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the vector with the minimum coordinates.  <a href="structspk_1_1IVector2.html#ae64ebb9cf02e5bbf329ea31d35e29841">More...</a><br /></td></tr>
<tr class="separator:ae64ebb9cf02e5bbf329ea31d35e29841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452209253a7a42351fc09951297f7d4d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a452209253a7a42351fc09951297f7d4d">max</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_min, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_max)</td></tr>
<tr class="memdesc:a452209253a7a42351fc09951297f7d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the vector with the maximum coordinates.  <a href="structspk_1_1IVector2.html#a452209253a7a42351fc09951297f7d4d">More...</a><br /></td></tr>
<tr class="separator:a452209253a7a42351fc09951297f7d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fd8293e2ff4b4bfa398dd70d158081"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a34fd8293e2ff4b4bfa398dd70d158081">isInsideRectangle</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_point, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_cornerA, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_cornerB)</td></tr>
<tr class="memdesc:a34fd8293e2ff4b4bfa398dd70d158081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a point is inside a rectangle defined by two corner points.  <a href="structspk_1_1IVector2.html#a34fd8293e2ff4b4bfa398dd70d158081">More...</a><br /></td></tr>
<tr class="separator:a34fd8293e2ff4b4bfa398dd70d158081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae564274f20ad50bb14dc2d34806cdec4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#ae564274f20ad50bb14dc2d34806cdec4">lerp</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_startingPoint, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_endingPoint, float t)</td></tr>
<tr class="memdesc:ae564274f20ad50bb14dc2d34806cdec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates linearly between two points.  <a href="structspk_1_1IVector2.html#ae564274f20ad50bb14dc2d34806cdec4">More...</a><br /></td></tr>
<tr class="separator:ae564274f20ad50bb14dc2d34806cdec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7aef6e160a85e33668c18c5e743127ef"><td class="memItemLeft" align="right" valign="top"><a id="a7aef6e160a85e33668c18c5e743127ef"></a>
TType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a7aef6e160a85e33668c18c5e743127ef">x</a></td></tr>
<tr class="memdesc:a7aef6e160a85e33668c18c5e743127ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The x-coordinate of the vector. <br /></td></tr>
<tr class="separator:a7aef6e160a85e33668c18c5e743127ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc7c3164247217231e53c0b75e21e3b"><td class="memItemLeft" align="right" valign="top"><a id="aefc7c3164247217231e53c0b75e21e3b"></a>
TType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#aefc7c3164247217231e53c0b75e21e3b">y</a></td></tr>
<tr class="memdesc:aefc7c3164247217231e53c0b75e21e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The y-coordinate of the vector. <br /></td></tr>
<tr class="separator:aefc7c3164247217231e53c0b75e21e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0ad00eba4b802fae1acede9ef72d21bd"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html#a0ad00eba4b802fae1acede9ef72d21bd">operator&lt;&lt;</a> (std::wostream &amp;p_os, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a> &amp;p_self)</td></tr>
<tr class="memdesc:a0ad00eba4b802fae1acede9ef72d21bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of &lt;&lt; operator for output stream.  <a href="structspk_1_1IVector2.html#a0ad00eba4b802fae1acede9ef72d21bd">More...</a><br /></td></tr>
<tr class="separator:a0ad00eba4b802fae1acede9ef72d21bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TType&gt;<br />
class spk::IVector2&lt; TType &gt;</h3>

<p>A two-dimensional vector class with variable type. </p>
<p>This class represents a two-dimensional vector. It provides a number of methods for vector operations. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>Type used for vector coordinates. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad681cb3d88fd9a4ca1e60c3c44e600b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad681cb3d88fd9a4ca1e60c3c44e600b6">&#9670;&nbsp;</a></span>IVector2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::<a class="el" href="structspk_1_1IVector2.html">IVector2</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates a two-dimensional vector with coordinates (0,0). </p>

</div>
</div>
<a id="ae197d470bdc2579bd6434f1d23e569bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae197d470bdc2579bd6434f1d23e569bc">&#9670;&nbsp;</a></span>IVector2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::<a class="el" href="structspk_1_1IVector2.html">IVector2</a> </td>
          <td>(</td>
          <td class="paramtype">const TOtherType &amp;&#160;</td>
          <td class="paramname"><em>p_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that initializes both coordinates with a single value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The value to be used for both coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3199f7709d8d15633920c7602b1c1e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3199f7709d8d15633920c7602b1c1e55">&#9670;&nbsp;</a></span>IVector2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::<a class="el" href="structspk_1_1IVector2.html">IVector2</a> </td>
          <td>(</td>
          <td class="paramtype">const TOtherType &amp;&#160;</td>
          <td class="paramname"><em>p_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TOtherType &amp;&#160;</td>
          <td class="paramname"><em>p_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that initializes the vector with two values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_x</td><td>The value to be used for the x-coordinate. </td></tr>
    <tr><td class="paramname">p_y</td><td>The value to be used for the y-coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4c3925ad849ad4d9b1bdba9a8c0d879c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3925ad849ad4d9b1bdba9a8c0d879c">&#9670;&nbsp;</a></span>angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::angle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_center</em> = <code><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;&#160;TType&#160;&gt;(0,&#160;0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the angle between this vector and another vector, with respect to a center vector. </p>
<p>This method calculates the angle in degrees between this vector and another vector, with respect to a center vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOtherType</td><td>The type of the other vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object to compute the angle to. </td></tr>
    <tr><td class="paramname">p_center</td><td>The center <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object. Defaults to a zero vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle in degrees between this vector and the other vector, with respect to the center vector. </dd></dl>

</div>
</div>
<a id="ac22c9a8609ce9b7f2215eff7c120ed0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22c9a8609ce9b7f2215eff7c120ed0c">&#9670;&nbsp;</a></span>ceiling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a> <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::ceiling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up the coordinates of a vector. </p>
<p>This method rounds up the coordinates of a given <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_vector</td><td>The vector to be rounded up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector with rounded up coordinates. </dd></dl>

</div>
</div>
<a id="a4d5cc1aceeca9b90fcecf6d6fe49520d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5cc1aceeca9b90fcecf6d6fe49520d">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a> <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em> = <code><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;&#160;TType&#160;&gt;(0,&#160;0)</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the 2D cross product with another vector. </p>
<p>This method calculates the 2D cross product of this vector with another vector. The result is a new vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOtherType</td><td>The type of the other vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object to compute the cross product with. Defaults to a zero vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of this vector and the other vector. </dd></dl>

</div>
</div>
<a id="a6ab6d332aa26f3da116169b39014f113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab6d332aa26f3da116169b39014f113">&#9670;&nbsp;</a></span>crossZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::crossZ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the z-component of the cross product with another vector. </p>
<p>This method calculates the z-component of the 2D cross product of this vector with another vector. The result is a scalar. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOtherType</td><td>The type of the other vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object to compute the cross product with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The z-component of the cross product of this vector and the other vector. </dd></dl>

</div>
</div>
<a id="abf3cb20ecff4c986f8a7d602e89623a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3cb20ecff4c986f8a7d602e89623a2">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Euclidean distance between this vector and another vector. </p>
<p>This method calculates the Euclidean distance (or L2 distance) between this vector and another vector. The Euclidean distance is the square root of the sum of the squares of differences in each coordinate. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOtherType</td><td>The type of the other vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object to compute the distance to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euclidean distance between this vector and the other vector. </dd></dl>

</div>
</div>
<a id="a5b615184fb3c906955819e01958102bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b615184fb3c906955819e01958102bc">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_center</em> = <code><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;&#160;TType&#160;&gt;(0,&#160;0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the dot product with another vector, with respect to a center vector. </p>
<p>This method calculates the dot product of this vector with another vector, with respect to a center vector. The result is a scalar. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOtherType</td><td>The type of the other vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object to compute the dot product with. </td></tr>
    <tr><td class="paramname">p_center</td><td>The center <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object. Defaults to a zero vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dot product of this vector and the other vector, with respect to the center vector. </dd></dl>

</div>
</div>
<a id="af58b4937f57ec150690b653144e627f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58b4937f57ec150690b653144e627f2">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a> <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds down the coordinates of a vector. </p>
<p>This method rounds down the coordinates of a given <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_vector</td><td>The vector to be rounded down. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector with rounded down coordinates. </dd></dl>

</div>
</div>
<a id="a94bb60fe03d90225da1337147ac4bb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bb60fe03d90225da1337147ac4bb72">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a> <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts this vector. </p>
<p>This method inverts this vector by multiplying each coordinate by -1. The result is a new vector pointing in the opposite direction. </p><dl class="section return"><dt>Returns</dt><dd>The inverted vector. </dd></dl>

</div>
</div>
<a id="a34fd8293e2ff4b4bfa398dd70d158081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fd8293e2ff4b4bfa398dd70d158081">&#9670;&nbsp;</a></span>isInsideRectangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::isInsideRectangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_cornerA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_cornerB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a point is inside a rectangle defined by two corner points. </p>
<p>This method checks if a given point (as an <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object) is inside a rectangle defined by two corner points (as <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> objects). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_point</td><td>The point to be checked. </td></tr>
    <tr><td class="paramname">p_cornerA</td><td>The first corner point of the rectangle. </td></tr>
    <tr><td class="paramname">p_cornerB</td><td>The second corner point of the rectangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point is inside the rectangle, false otherwise. </dd></dl>

</div>
</div>
<a id="ae564274f20ad50bb14dc2d34806cdec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae564274f20ad50bb14dc2d34806cdec4">&#9670;&nbsp;</a></span>lerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a> <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::lerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_startingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_endingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolates linearly between two points. </p>
<p>This method performs a linear interpolation between two points, creating a smooth transition from the starting point to the ending point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_startingPoint</td><td>The starting point for the interpolation. </td></tr>
    <tr><td class="paramname">p_endingPoint</td><td>The ending point for the interpolation. </td></tr>
    <tr><td class="paramname">t</td><td>The interpolation parameter, ranging from 0 (start point) to 1 (end point). For values outside this range, the function extrapolates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated vector. </dd></dl>

</div>
</div>
<a id="a452209253a7a42351fc09951297f7d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452209253a7a42351fc09951297f7d4d">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a> <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the vector with the maximum coordinates. </p>
<p>This method calculates the <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object with the maximum coordinates from two given vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_min</td><td>The first vector. </td></tr>
    <tr><td class="paramname">p_max</td><td>The second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector with the maximum coordinates. </dd></dl>

</div>
</div>
<a id="ae64ebb9cf02e5bbf329ea31d35e29841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64ebb9cf02e5bbf329ea31d35e29841">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a> <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the vector with the minimum coordinates. </p>
<p>This method calculates the <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object with the minimum coordinates from two given vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_min</td><td>The first vector. </td></tr>
    <tr><td class="paramname">p_max</td><td>The second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector with the minimum coordinates. </dd></dl>

</div>
</div>
<a id="aa0d0c755988c4ce9ec8e86e1744d997e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d0c755988c4ce9ec8e86e1744d997e">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the norm (or length) of this vector. </p>
<p>This method calculates the Euclidean norm (also known as the L2 norm) of this vector, which is the square root of the sum of the squares of the coordinates. </p><dl class="section return"><dt>Returns</dt><dd>The norm of the vector. </dd></dl>

</div>
</div>
<a id="a6bc80581ee0fb7ce5f10b751b85fa0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc80581ee0fb7ce5f10b751b85fa0cb">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;float&gt; <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes this vector. </p>
<p>This method normalizes this vector by dividing each coordinate by the norm of the vector. The resulting vector has a norm of 1. If the norm of the vector is zero, a runtime error is thrown. </p><dl class="section return"><dt>Returns</dt><dd>The normalized vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the norm of the vector is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4960cc3b4ade5cfd48cd0b78281d179a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4960cc3b4ade5cfd48cd0b78281d179a">&#9670;&nbsp;</a></span>operator IVector2&lt; TOtherType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type-casting operator. </p>
<p>Allows an instance of the class to be type-casted to an instance of <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> of another type. </p><dl class="section return"><dt>Returns</dt><dd>An instance of <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> of the new type. </dd></dl>

</div>
</div>
<a id="a8a7d7e368595e4a4db1580995d7df6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7d7e368595e4a4db1580995d7df6f6">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of != operator. </p>
<p>This operator is used to compare if two <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> objects are not equal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> objects are not equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a409c7ef14a15f0e7bee9e781ea3f029c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409c7ef14a15f0e7bee9e781ea3f029c">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of * operator. </p>
<p>This operator is used to multiply two <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a>. </dd></dl>

</div>
</div>
<a id="a0609e1b115b35f3293a19e9f1b3aa91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0609e1b115b35f3293a19e9f1b3aa91c">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of *= operator. </p>
<p>This operator is used to multiply this object by another <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> and assign the result to this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to multiply with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d6df11d0dea89825de285227208b4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6df11d0dea89825de285227208b4e8">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of + operator. </p>
<p>This operator is used to add two <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a>. </dd></dl>

</div>
</div>
<a id="a46f20fbffbe8c392bf857f84f6175c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f20fbffbe8c392bf857f84f6175c33">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of += operator. </p>
<p>This operator is used to add another <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to this object and assign the result to this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93181e2a39090202e764fe87e5a6d1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93181e2a39090202e764fe87e5a6d1c5">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of - operator. </p>
<p>This operator is used to subtract two <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a>. </dd></dl>

</div>
</div>
<a id="a96c33ee627ed1700aff6627261a074ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c33ee627ed1700aff6627261a074ac">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of -= operator. </p>
<p>This operator is used to subtract another <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> from this object and assign the result to this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to subtract. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d8fac9e93e024514717ef2594724aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8fac9e93e024514717ef2594724aec">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of / operator. </p>
<p>This operator is used to divide two <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if an attempt is made to divide by zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8158dcf13f51999650b00e83c36be525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8158dcf13f51999650b00e83c36be525">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of /= operator. </p>
<p>This operator is used to divide this object by another <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> and assign the result to this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if an attempt is made to divide by zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50ee09f391a89938f95501f6f830818d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ee09f391a89938f95501f6f830818d">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of &lt; operator. </p>
<p>This operator is used to compare if one <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object is less than another. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object is less than the other, false otherwise. </dd></dl>

</div>
</div>
<a id="ae1604ed3d5d9945e9183396dc976d906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1604ed3d5d9945e9183396dc976d906">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of &lt;= operator. </p>
<p>This operator is used to compare if one <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object is less than or equal to another. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object is less than or equal to the other, false otherwise. </dd></dl>

</div>
</div>
<a id="a19a45be30c1cb18600add47dddd15ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a45be30c1cb18600add47dddd15ce1">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of == operator. </p>
<p>This operator is used to compare if two <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> objects are equal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> objects are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="ab1b6a3babc24fbb384fde2327590f4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b6a3babc24fbb384fde2327590f4ef">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of &gt; operator. </p>
<p>This operator is used to compare if one <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object is greater than another. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object is greater than the other, false otherwise. </dd></dl>

</div>
</div>
<a id="acd97e47a3bfd966a412f9520c98748d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd97e47a3bfd966a412f9520c98748d1">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of &gt;= operator. </p>
<p>This operator is used to compare if one <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object is greater than or equal to another. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_other</td><td>The other <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object is greater than or equal to the other, false otherwise. </dd></dl>

</div>
</div>
<a id="a2a657d838bdfcbb18dd0309977d34d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a657d838bdfcbb18dd0309977d34d5b">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<div class="memtemplate">
template&lt;typename TOtherType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a> <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TOtherType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>p_angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates this vector around a given center point. </p>
<p>This method rotates this vector around a given center point by a specified angle. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOtherType</td><td>The type of the center vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_center</td><td>The <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object that serves as the rotation center point. </td></tr>
    <tr><td class="paramname">p_angle</td><td>The angle in degrees by which to rotate the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotated vector. </dd></dl>

</div>
</div>
<a id="a173f7d72b11d82a87db01e6a6dfe625e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173f7d72b11d82a87db01e6a6dfe625e">&#9670;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structspk_1_1IVector2.html">IVector2</a> <a class="el" href="structspk_1_1IVector2.html">spk::IVector2</a>&lt; TType &gt;::round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the coordinates of a vector to the nearest integer. </p>
<p>This method rounds the coordinates of a given <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object to the nearest integer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_vector</td><td>The vector to be rounded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector with rounded coordinates. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0ad00eba4b802fae1acede9ef72d21bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad00eba4b802fae1acede9ef72d21bd">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_self</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of &lt;&lt; operator for output stream. </p>
<p>This operator is used to output the content of an <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">p_self</td><td>The <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> object to output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>includes/math/<a class="el" href="spk__vector2_8hpp_source.html">spk_vector2.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
