<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparkle: spk Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sparkle
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">spk Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains the definitions and implementations related to Perlin noise generation.  
<a href="namespacespk.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1APIModule.html">APIModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing the API interactions.  <a href="classspk_1_1APIModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1WindowModule.html">WindowModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing the application window.  <a href="classspk_1_1WindowModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1KeyboardModule.html">KeyboardModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing the keyboard interactions.  <a href="classspk_1_1KeyboardModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1IMessageConsumerModule.html">IMessageConsumerModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for modules that consume messages.  <a href="classspk_1_1IMessageConsumerModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1MouseModule.html">MouseModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing the mouse interactions.  <a href="classspk_1_1MouseModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ProfilerModule.html">ProfilerModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to profile and manage the frames-per-second rates of the application.  <a href="classspk_1_1ProfilerModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1SystemModule.html">SystemModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing system-level interactions.  <a href="classspk_1_1SystemModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1TimeModule.html">TimeModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing time-related functionality.  <a href="classspk_1_1TimeModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1WidgetModule.html">WidgetModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing widgets within the application.  <a href="classspk_1_1WidgetModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1AbstractApplication.html">AbstractApplication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for the application.  <a href="classspk_1_1AbstractApplication.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Application.html">Application</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main class for managing application.  <a href="classspk_1_1Application.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html">DataBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing data buffers.  <a href="classspk_1_1DataBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Pool.html">Pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic pool class that manages the creation and deletion of objects.  <a href="classspk_1_1Pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Profiler.html">Profiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A singleton class that handles profiling using various chronometers.  <a href="classspk_1_1Profiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ActivableObject.html">ActivableObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an activatable object. This class provides functionality to activate and deactivate an object. It also allows adding activation and deactivation callbacks.  <a href="classspk_1_1ActivableObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Activity.html">Activity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an activity. This class defines an activity that can be managed by an ActivityManager. It provides methods for updating, moving to the next step, starting, and checking the status of the activity.  <a href="classspk_1_1Activity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1TimedActivity.html">TimedActivity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an activity that executes a function after a specified delay.  <a href="classspk_1_1TimedActivity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1RetryActivity.html">RetryActivity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an activity that repeatedly executes a function until it returns true.  <a href="classspk_1_1RetryActivity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ActivityScheduler.html">ActivityScheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows activitee to follow each other.  <a href="classspk_1_1ActivityScheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1CommandParser.html">CommandParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classspk_1_1CommandParser.html" title="The CommandParser class is responsible for parsing and processing commands.">CommandParser</a> class is responsible for parsing and processing commands.  <a href="classspk_1_1CommandParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ContextManager.html">ContextManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1ContextManager.html" title="ContextManager is a singleton template class that manages ReadWrite and ReadOnly access to a common c...">ContextManager</a> is a singleton template class that manages ReadWrite and ReadOnly access to a common context.  <a href="classspk_1_1ContextManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ContractProvider.html">ContractProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classspk_1_1ContractProvider_1_1Contract.html" title="Represent the ownership of a callback and allow users to interact with it.">Contract</a> with a callback function and a callbackContainer.  <a href="classspk_1_1ContractProvider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1InherenceObject.html">InherenceObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1InherenceObject.html" title="InherenceObject class template.">InherenceObject</a> class template.  <a href="classspk_1_1InherenceObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Memento.html">Memento</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a memento in the <a class="el" href="classspk_1_1Memento.html" title="A class representing a memento in the Memento design pattern.">Memento</a> design pattern.  <a href="classspk_1_1Memento.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1StandardType.html">StandardType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template for standard layout types, derived from <a class="el" href="classspk_1_1Memento.html" title="A class representing a memento in the Memento design pattern.">Memento</a>.  <a href="structspk_1_1StandardType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Observer.html">Observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1Observer.html" title="Observer class template.">Observer</a> class template.  <a href="classspk_1_1Observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Singleton.html">Singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1Singleton.html" title="Singleton class template.">Singleton</a> class template.  <a href="classspk_1_1Singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1StateMachine.html">StateMachine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classspk_1_1StateMachine.html" title="A StateMachine class that handles different state transitions. It allows setting callbacks for state ...">StateMachine</a> class that handles different state transitions. It allows setting callbacks for state transitions and state executions.  <a href="classspk_1_1StateMachine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1StatedObject.html">StatedObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class who manage state switching. This class representing an object who can be in different state. the class additionnaly store lambdas to call uppon specific state. Each lambda is provided to the user as Contract object.  <a href="classspk_1_1StatedObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template for managing a value with default and custom states.  <a href="classspk_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Window.html">Window</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1Singleton.html" title="Singleton class template.">Singleton</a> class for window.  <a href="classspk_1_1Window.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 3D object, and provides methods to insert and access its contents. Additionnaly, it provide a method to bake normals based on indexes definition.  <a href="classspk_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Input.html">Input</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class providing a common interface for input classes in the 'spk' library.  <a href="classspk_1_1Input.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1InputGroup.html">InputGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a group of input objects.  <a href="classspk_1_1InputGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1KeyInput.html">KeyInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete class derived from <a class="el" href="classspk_1_1Input.html" title="Abstract class providing a common interface for input classes in the &#39;spk&#39; library.">Input</a> that represents keyboard input.  <a href="classspk_1_1KeyInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Keyboard.html">Keyboard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1Singleton.html" title="Singleton class template.">Singleton</a> class for keyboard inputs.  <a href="classspk_1_1Keyboard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mouse.html">Mouse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1Singleton.html" title="Singleton class template.">Singleton</a> class for <a class="el" href="classspk_1_1Mouse.html" title="Singleton class for Mouse.">Mouse</a>.  <a href="classspk_1_1Mouse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1MouseInput.html">MouseInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete class derived from <a class="el" href="classspk_1_1Input.html" title="Abstract class providing a common interface for input classes in the &#39;spk&#39; library.">Input</a> that represents mouse input.  <a href="classspk_1_1MouseInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1MouseMovementInput.html">MouseMovementInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete class derived from <a class="el" href="classspk_1_1Input.html" title="Abstract class providing a common interface for input classes in the &#39;spk&#39; library.">Input</a> that represents mouse movement input.  <a href="classspk_1_1MouseMovementInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1IOStream.html">IOStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream with a custom prefix, suitable for logging or debugging.  <a href="classspk_1_1IOStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1IPerlin.html">IPerlin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functionality related to Perlin noise generation.  <a href="classspk_1_1IPerlin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Perlin1D.html">Perlin1D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Perlin noise generator for one-dimensional input.  <a href="classspk_1_1Perlin1D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Perlin2D.html">Perlin2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Perlin noise generator for two-dimensional input.  <a href="classspk_1_1Perlin2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Perlin3D.html">Perlin3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Perlin noise generator for three-dimensional input.  <a href="classspk_1_1Perlin3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1Matrix4x4.html">Matrix4x4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 4x4 matrix.  <a href="structspk_1_1Matrix4x4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1PseudoRandomGenerator.html">PseudoRandomGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classspk_1_1PseudoRandomGenerator.html" title="The PseudoRandomGenerator class template for generating pseudo random numbers.">PseudoRandomGenerator</a> class template for generating pseudo random numbers.  <a href="classspk_1_1PseudoRandomGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1RandomGenerator.html">RandomGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator template class.  <a href="classspk_1_1RandomGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html">IVector2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A two-dimensional vector class with variable type.  <a href="structspk_1_1IVector2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector3.html">IVector3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic 3D vector class template.  <a href="structspk_1_1IVector3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IsContainer.html">IsContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction for checking if a type is a container.  <a href="structspk_1_1IsContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IsContainer_3_01T_00_01std_1_1void__t_3_01decltype_07std_1_1declval_3_01T_01_4_07_091bae1cdb89f7c308b50873cf3c7f724.html">IsContainer&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().begin()), decltype(std::declval&lt; T &gt;().end()), typename T::value_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1TranslationAtlas.html">TranslationAtlas</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to store localized strings.  <a href="classspk_1_1TranslationAtlas.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Chronometer.html">Chronometer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple chronometer class to measure elapsed time.  <a href="classspk_1_1Chronometer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1TimeMetrics.html">TimeMetrics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for recording time-related metrics in the application.  <a href="classspk_1_1TimeMetrics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating and managing a timer.  <a href="classspk_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1PersistentWorker.html">PersistentWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating and managing a persistent worker thread.  <a href="classspk_1_1PersistentWorker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Promise.html">Promise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for providing a promise with a value.  <a href="classspk_1_1Promise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Thread.html">Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating and managing a thread.  <a href="classspk_1_1Thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ThreadSafeQueue.html">ThreadSafeQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread-safe queue implementation.  <a href="classspk_1_1ThreadSafeQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1WorkerPool.html">WorkerPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating and managing a pool of worker threads.  <a href="classspk_1_1WorkerPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Worker.html">Worker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating a worker thread.  <a href="classspk_1_1Worker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9b7d33188f36fb94cdde3264ccc16e20"><td class="memItemLeft" align="right" valign="top"><a id="a9b7d33188f36fb94cdde3264ccc16e20"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a9b7d33188f36fb94cdde3264ccc16e20">Vector2</a> = <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; float &gt;</td></tr>
<tr class="memdesc:a9b7d33188f36fb94cdde3264ccc16e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> with float type. <br /></td></tr>
<tr class="separator:a9b7d33188f36fb94cdde3264ccc16e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b9738cf9ec67888207021519d1a673"><td class="memItemLeft" align="right" valign="top"><a id="a81b9738cf9ec67888207021519d1a673"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">Vector2Int</a> = <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; int &gt;</td></tr>
<tr class="memdesc:a81b9738cf9ec67888207021519d1a673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> with int type. <br /></td></tr>
<tr class="separator:a81b9738cf9ec67888207021519d1a673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e1f556496e4d67f41e1f7807069e54"><td class="memItemLeft" align="right" valign="top"><a id="a71e1f556496e4d67f41e1f7807069e54"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a71e1f556496e4d67f41e1f7807069e54">Vector2UInt</a> = <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; unsigned int &gt;</td></tr>
<tr class="memdesc:a71e1f556496e4d67f41e1f7807069e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> with unsigned int type. <br /></td></tr>
<tr class="separator:a71e1f556496e4d67f41e1f7807069e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ce29c89e3ca14bf467a94db03d5939"><td class="memItemLeft" align="right" valign="top"><a id="a25ce29c89e3ca14bf467a94db03d5939"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a25ce29c89e3ca14bf467a94db03d5939">Vector3</a> = <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; float &gt;</td></tr>
<tr class="memdesc:a25ce29c89e3ca14bf467a94db03d5939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector3.html" title="A generic 3D vector class template.">IVector3</a> with float type. <br /></td></tr>
<tr class="separator:a25ce29c89e3ca14bf467a94db03d5939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7d4d8007cf977199c3ba89fd52e283"><td class="memItemLeft" align="right" valign="top"><a id="afa7d4d8007cf977199c3ba89fd52e283"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#afa7d4d8007cf977199c3ba89fd52e283">Vector3Int</a> = <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; int &gt;</td></tr>
<tr class="memdesc:afa7d4d8007cf977199c3ba89fd52e283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector3.html" title="A generic 3D vector class template.">IVector3</a> with int type. <br /></td></tr>
<tr class="separator:afa7d4d8007cf977199c3ba89fd52e283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b7e560fadd4adf03bcea8fb62de5a8"><td class="memItemLeft" align="right" valign="top"><a id="aa6b7e560fadd4adf03bcea8fb62de5a8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aa6b7e560fadd4adf03bcea8fb62de5a8">Vector3UInt</a> = <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; unsigned int &gt;</td></tr>
<tr class="memdesc:aa6b7e560fadd4adf03bcea8fb62de5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector3.html" title="A generic 3D vector class template.">IVector3</a> with unsigned int type. <br /></td></tr>
<tr class="separator:aa6b7e560fadd4adf03bcea8fb62de5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aed6527896d34c2628aec65a369dee252"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aed6527896d34c2628aec65a369dee252">InputState</a> { <b>Up</b>
, <b>Pressed</b>
, <b>Down</b>
, <b>Released</b>
 }</td></tr>
<tr class="memdesc:aed6527896d34c2628aec65a369dee252"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of an input device like a button or key.  <a href="namespacespk.html#aed6527896d34c2628aec65a369dee252">More...</a><br /></td></tr>
<tr class="separator:aed6527896d34c2628aec65a369dee252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba">to_wstring</a> (const <a class="el" href="namespacespk.html#aed6527896d34c2628aec65a369dee252">InputState</a> &amp;p_status)</td></tr>
<tr class="memdesc:a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an InputState value to a string.  <a href="namespacespk.html#a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba">More...</a><br /></td></tr>
<tr class="separator:a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98695e9de44684d6aaecc705564cd6d8"><td class="memItemLeft" align="right" valign="top">const std::wstring &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a98695e9de44684d6aaecc705564cd6d8">to_wstring</a> (const <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28">Keyboard::Key</a> &amp;p_key)</td></tr>
<tr class="memdesc:a98695e9de44684d6aaecc705564cd6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28" title="Enum for representing keyboard keys.">Keyboard::Key</a> to a string.  <a href="namespacespk.html#a98695e9de44684d6aaecc705564cd6d8">More...</a><br /></td></tr>
<tr class="separator:a98695e9de44684d6aaecc705564cd6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0d135246aecf232855d7d804bb55bd"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a8b0d135246aecf232855d7d804bb55bd">to_wstring</a> (const <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5">Mouse::Button</a> &amp;p_button)</td></tr>
<tr class="memdesc:a8b0d135246aecf232855d7d804bb55bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5" title="Enum for mouse buttons.">Mouse::Button</a> value to a wstring.  <a href="namespacespk.html#a8b0d135246aecf232855d7d804bb55bd">More...</a><br /></td></tr>
<tr class="separator:a8b0d135246aecf232855d7d804bb55bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542066c55ed7a3bca5a973af1e8bf8cd"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a542066c55ed7a3bca5a973af1e8bf8cd">to_wstring</a> (const <a class="el" href="classspk_1_1IPerlin.html#a3266c3dd973db71cfd0f81a6b8ff4540">spk::IPerlin::Interpolation</a> &amp;p_interpolation)</td></tr>
<tr class="memdesc:a542066c55ed7a3bca5a973af1e8bf8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an Interpolation type to a string representation.  <a href="namespacespk.html#a542066c55ed7a3bca5a973af1e8bf8cd">More...</a><br /></td></tr>
<tr class="separator:a542066c55ed7a3bca5a973af1e8bf8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c500689e1936587d90db1f1328ceb4"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ad6c500689e1936587d90db1f1328ceb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#ad6c500689e1936587d90db1f1328ceb4">operator+</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:ad6c500689e1936587d90db1f1328ceb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the addition operator for an arithmetic value and a vector.  <a href="namespacespk.html#ad6c500689e1936587d90db1f1328ceb4">More...</a><br /></td></tr>
<tr class="separator:ad6c500689e1936587d90db1f1328ceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443c70714a630e0cbc2199d56b92cc03"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a443c70714a630e0cbc2199d56b92cc03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a443c70714a630e0cbc2199d56b92cc03">operator-</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a443c70714a630e0cbc2199d56b92cc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the substraction operator for an arithmetic value and a vector.  <a href="namespacespk.html#a443c70714a630e0cbc2199d56b92cc03">More...</a><br /></td></tr>
<tr class="separator:a443c70714a630e0cbc2199d56b92cc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4d3ecda52ee833bc55ca7ece2f940e"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:adc4d3ecda52ee833bc55ca7ece2f940e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#adc4d3ecda52ee833bc55ca7ece2f940e">operator*</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:adc4d3ecda52ee833bc55ca7ece2f940e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the multiplication operator for an arithmetic value and a vector.  <a href="namespacespk.html#adc4d3ecda52ee833bc55ca7ece2f940e">More...</a><br /></td></tr>
<tr class="separator:adc4d3ecda52ee833bc55ca7ece2f940e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8a9957f5dff3695f49beb037108568"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a4a8a9957f5dff3695f49beb037108568"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a4a8a9957f5dff3695f49beb037108568">operator/</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a4a8a9957f5dff3695f49beb037108568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the division operator for an arithmetic value and a vector.  <a href="namespacespk.html#a4a8a9957f5dff3695f49beb037108568">More...</a><br /></td></tr>
<tr class="separator:a4a8a9957f5dff3695f49beb037108568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa420d958f7152d62c0f50b806c26a0ff"><td class="memTemplParams" colspan="2">template&lt;typename TType &gt; </td></tr>
<tr class="memitem:aa420d958f7152d62c0f50b806c26a0ff"><td class="memTemplItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#aa420d958f7152d62c0f50b806c26a0ff">to_wstring</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:aa420d958f7152d62c0f50b806c26a0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector to a wstring.  <a href="namespacespk.html#aa420d958f7152d62c0f50b806c26a0ff">More...</a><br /></td></tr>
<tr class="separator:aa420d958f7152d62c0f50b806c26a0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8581e17fe52f716d72b87d12669f7620"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a8581e17fe52f716d72b87d12669f7620"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a8581e17fe52f716d72b87d12669f7620">operator+</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a8581e17fe52f716d72b87d12669f7620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded addition operator to add a value to a vector.  <a href="namespacespk.html#a8581e17fe52f716d72b87d12669f7620">More...</a><br /></td></tr>
<tr class="separator:a8581e17fe52f716d72b87d12669f7620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70753e5aacb8a5eb2f6ae254c139e44c"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a70753e5aacb8a5eb2f6ae254c139e44c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a70753e5aacb8a5eb2f6ae254c139e44c">operator-</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a70753e5aacb8a5eb2f6ae254c139e44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded subtraction operator to subtract a value from a vector.  <a href="namespacespk.html#a70753e5aacb8a5eb2f6ae254c139e44c">More...</a><br /></td></tr>
<tr class="separator:a70753e5aacb8a5eb2f6ae254c139e44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f95f63066ab643b13ad27871d3a0aca"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a4f95f63066ab643b13ad27871d3a0aca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a4f95f63066ab643b13ad27871d3a0aca">operator*</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a4f95f63066ab643b13ad27871d3a0aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded multiplication operator to multiply a value with a vector.  <a href="namespacespk.html#a4f95f63066ab643b13ad27871d3a0aca">More...</a><br /></td></tr>
<tr class="separator:a4f95f63066ab643b13ad27871d3a0aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9fb6d5f31677ea83f5e5d3d44c6ed2"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:abc9fb6d5f31677ea83f5e5d3d44c6ed2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#abc9fb6d5f31677ea83f5e5d3d44c6ed2">operator/</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:abc9fb6d5f31677ea83f5e5d3d44c6ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded division operator to divide a value by a vector.  <a href="namespacespk.html#abc9fb6d5f31677ea83f5e5d3d44c6ed2">More...</a><br /></td></tr>
<tr class="separator:abc9fb6d5f31677ea83f5e5d3d44c6ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a7d505764b6392380bf9d30d007dba"><td class="memTemplParams" colspan="2">template&lt;typename TType &gt; </td></tr>
<tr class="memitem:a49a7d505764b6392380bf9d30d007dba"><td class="memTemplItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a49a7d505764b6392380bf9d30d007dba">to_wstring</a> (const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a49a7d505764b6392380bf9d30d007dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector to a wstring.  <a href="namespacespk.html#a49a7d505764b6392380bf9d30d007dba">More...</a><br /></td></tr>
<tr class="separator:a49a7d505764b6392380bf9d30d007dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfb867af25d965b131886fe857d23d4"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a3bfb867af25d965b131886fe857d23d4">methodName</a> (const std::string &amp;prettyFunction)</td></tr>
<tr class="memdesc:a3bfb867af25d965b131886fe857d23d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the method name from the provided pretty function.  <a href="namespacespk.html#a3bfb867af25d965b131886fe857d23d4">More...</a><br /></td></tr>
<tr class="separator:a3bfb867af25d965b131886fe857d23d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd0e04975ab0187d20665ab8a864158"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aefd0e04975ab0187d20665ab8a864158">className</a> (const std::string &amp;prettyFunction)</td></tr>
<tr class="memdesc:aefd0e04975ab0187d20665ab8a864158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the class name from the provided pretty function.  <a href="namespacespk.html#aefd0e04975ab0187d20665ab8a864158">More...</a><br /></td></tr>
<tr class="separator:aefd0e04975ab0187d20665ab8a864158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7220789e458bf250bb05472cd28acc6b"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a7220789e458bf250bb05472cd28acc6b">methodName</a> (const std::wstring &amp;prettyFunction)</td></tr>
<tr class="memdesc:a7220789e458bf250bb05472cd28acc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the method name from the provided wide string pretty function.  <a href="namespacespk.html#a7220789e458bf250bb05472cd28acc6b">More...</a><br /></td></tr>
<tr class="separator:a7220789e458bf250bb05472cd28acc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcc5509d013801fd4d0ccf7c64cd83e"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#abfcc5509d013801fd4d0ccf7c64cd83e">className</a> (const std::wstring &amp;prettyFunction)</td></tr>
<tr class="memdesc:abfcc5509d013801fd4d0ccf7c64cd83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the class name from the provided wide string pretty function.  <a href="namespacespk.html#abfcc5509d013801fd4d0ccf7c64cd83e">More...</a><br /></td></tr>
<tr class="separator:abfcc5509d013801fd4d0ccf7c64cd83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e939c5f5ec45c7e93528a983b494a0d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a1e939c5f5ec45c7e93528a983b494a0d">stringSplit</a> (const std::wstring &amp;p_string, const std::wstring &amp;p_delim)</td></tr>
<tr class="memdesc:a1e939c5f5ec45c7e93528a983b494a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the input wide string into a vector of substrings based on the provided delimiter.  <a href="namespacespk.html#a1e939c5f5ec45c7e93528a983b494a0d">More...</a><br /></td></tr>
<tr class="separator:a1e939c5f5ec45c7e93528a983b494a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1da86df753aa08c134375767f1fd4b1"><td class="memItemLeft" align="right" valign="top">wchar_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#af1da86df753aa08c134375767f1fd4b1">getChar</a> (std::wfstream &amp;p_file)</td></tr>
<tr class="memdesc:af1da86df753aa08c134375767f1fd4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a wide character from the provided wide file stream.  <a href="namespacespk.html#af1da86df753aa08c134375767f1fd4b1">More...</a><br /></td></tr>
<tr class="separator:af1da86df753aa08c134375767f1fd4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f2918180da54f142029f041b9d1fa3"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#ae9f2918180da54f142029f041b9d1fa3">getStr</a> (std::wfstream &amp;p_file)</td></tr>
<tr class="memdesc:ae9f2918180da54f142029f041b9d1fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a wide string from the provided wide file stream.  <a href="namespacespk.html#ae9f2918180da54f142029f041b9d1fa3">More...</a><br /></td></tr>
<tr class="separator:ae9f2918180da54f142029f041b9d1fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1254ad34752aba2c1362dedb3b3c2175"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a1254ad34752aba2c1362dedb3b3c2175">getStringSplit</a> (std::wfstream &amp;p_file, const std::wstring &amp;p_delim, const int &amp;p_expectedSize=-1)</td></tr>
<tr class="memdesc:a1254ad34752aba2c1362dedb3b3c2175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and splits a wide string from the provided wide file stream based on the delimiter.  <a href="namespacespk.html#a1254ad34752aba2c1362dedb3b3c2175">More...</a><br /></td></tr>
<tr class="separator:a1254ad34752aba2c1362dedb3b3c2175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f89235a75499ada62763e9d3b2dec82"><td class="memItemLeft" align="right" valign="top">intmax_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a0f89235a75499ada62763e9d3b2dec82">positiveModulo</a> (intmax_t p_integer, intmax_t p_dividor)</td></tr>
<tr class="memdesc:a0f89235a75499ada62763e9d3b2dec82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the positive modulo of the given integer and divisor.  <a href="namespacespk.html#a0f89235a75499ada62763e9d3b2dec82">More...</a><br /></td></tr>
<tr class="separator:a0f89235a75499ada62763e9d3b2dec82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcd8e63bed947649a6876dc58f2b51c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a7fcd8e63bed947649a6876dc58f2b51c">listFile</a> (const std::wstring &amp;p_path, const std::wstring &amp;p_extension=L&quot;*&quot;)</td></tr>
<tr class="memdesc:a7fcd8e63bed947649a6876dc58f2b51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists all files in the specified directory path with the provided extension.  <a href="namespacespk.html#a7fcd8e63bed947649a6876dc58f2b51c">More...</a><br /></td></tr>
<tr class="separator:a7fcd8e63bed947649a6876dc58f2b51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf34a729deb44804d107aef9d2aaad5c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#acf34a729deb44804d107aef9d2aaad5c">listDir</a> (const std::wstring &amp;p_path)</td></tr>
<tr class="memdesc:acf34a729deb44804d107aef9d2aaad5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists all directories in the specified directory path.  <a href="namespacespk.html#acf34a729deb44804d107aef9d2aaad5c">More...</a><br /></td></tr>
<tr class="separator:acf34a729deb44804d107aef9d2aaad5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af968ab2db5e30a212aa373cddf7016d5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#af968ab2db5e30a212aa373cddf7016d5">wstringToString</a> (const std::wstring &amp;p_wstr)</td></tr>
<tr class="memdesc:af968ab2db5e30a212aa373cddf7016d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a wide string to a standard string.  <a href="namespacespk.html#af968ab2db5e30a212aa373cddf7016d5">More...</a><br /></td></tr>
<tr class="separator:af968ab2db5e30a212aa373cddf7016d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd100e360a6ec28d27838bedd6167f02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#afd100e360a6ec28d27838bedd6167f02">throwException</a> (const std::wstring &amp;p_errorLine)</td></tr>
<tr class="memdesc:afd100e360a6ec28d27838bedd6167f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a runtime_error with the provided error message as wide string.  <a href="namespacespk.html#afd100e360a6ec28d27838bedd6167f02">More...</a><br /></td></tr>
<tr class="separator:afd100e360a6ec28d27838bedd6167f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3f970e1658247b9ee9797f18727934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a0c3f970e1658247b9ee9797f18727934">redirectException</a> (std::exception &amp;e, const std::wstring *p_jobName)</td></tr>
<tr class="memdesc:a0c3f970e1658247b9ee9797f18727934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect an exception emitted by a thread during the execution of a job.  <a href="namespacespk.html#a0c3f970e1658247b9ee9797f18727934">More...</a><br /></td></tr>
<tr class="separator:a0c3f970e1658247b9ee9797f18727934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736875e1ee6b20eb1e2dd997ba8d354e"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a736875e1ee6b20eb1e2dd997ba8d354e">universalCodeDecoder</a> (const wchar_t &amp;p_code)</td></tr>
<tr class="memdesc:a736875e1ee6b20eb1e2dd997ba8d354e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns a non printable or unicode character into its universal code.  <a href="namespacespk.html#a736875e1ee6b20eb1e2dd997ba8d354e">More...</a><br /></td></tr>
<tr class="separator:a736875e1ee6b20eb1e2dd997ba8d354e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6848012087aaf1cc22b17362bd495af5"><td class="memItemLeft" align="right" valign="top">wchar_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a6848012087aaf1cc22b17362bd495af5">universalCodeEncoder</a> (const std::wstring &amp;p_code)</td></tr>
<tr class="memdesc:a6848012087aaf1cc22b17362bd495af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns a universal code into a non printable or unicode character.  <a href="namespacespk.html#a6848012087aaf1cc22b17362bd495af5">More...</a><br /></td></tr>
<tr class="separator:a6848012087aaf1cc22b17362bd495af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd3e0a18ce342e7152da660662a371d"><td class="memTemplParams" colspan="2">template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:a8cd3e0a18ce342e7152da660662a371d"><td class="memTemplItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a8cd3e0a18ce342e7152da660662a371d">numberLength</a> (NumericType p_number, unsigned short base=10)</td></tr>
<tr class="memdesc:a8cd3e0a18ce342e7152da660662a371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the length of a numeric value in a specified base.  <a href="namespacespk.html#a8cd3e0a18ce342e7152da660662a371d">More...</a><br /></td></tr>
<tr class="separator:a8cd3e0a18ce342e7152da660662a371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277832439260c3573165da6e04166b9c"><td class="memItemLeft" align="right" valign="top"><a id="a277832439260c3573165da6e04166b9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a277832439260c3573165da6e04166b9c">printCallStack</a> ()</td></tr>
<tr class="memdesc:a277832439260c3573165da6e04166b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the callstack of the current program. <br /></td></tr>
<tr class="separator:a277832439260c3573165da6e04166b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c67543ddcdbc17bd90377d145b8b7a"><td class="memItemLeft" align="right" valign="top"><a id="af4c67543ddcdbc17bd90377d145b8b7a"></a>
std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#af4c67543ddcdbc17bd90377d145b8b7a">stringToWString</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:af4c67543ddcdbc17bd90377d145b8b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a wstring. <br /></td></tr>
<tr class="separator:af4c67543ddcdbc17bd90377d145b8b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7a6a5cbca57b40e3f41c1c143eb09680"><td class="memItemLeft" align="right" valign="top"><a id="a7a6a5cbca57b40e3f41c1c143eb09680"></a>
thread_local <a class="el" href="classspk_1_1IOStream.html">spk::IOStream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a7a6a5cbca57b40e3f41c1c143eb09680">cout</a> = <a class="el" href="classspk_1_1IOStream.html">IOStream</a>(std::wcout)</td></tr>
<tr class="memdesc:a7a6a5cbca57b40e3f41c1c143eb09680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-local instances of <a class="el" href="classspk_1_1IOStream.html" title="An output stream with a custom prefix, suitable for logging or debugging.">IOStream</a> for standard output. <br /></td></tr>
<tr class="separator:a7a6a5cbca57b40e3f41c1c143eb09680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac7fd07dd4ad46d0ecd4a814bed814d"><td class="memItemLeft" align="right" valign="top"><a id="a2ac7fd07dd4ad46d0ecd4a814bed814d"></a>
thread_local <a class="el" href="classspk_1_1IOStream.html">spk::IOStream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a2ac7fd07dd4ad46d0ecd4a814bed814d">cerr</a> = <a class="el" href="classspk_1_1IOStream.html">IOStream</a>(std::wcerr)</td></tr>
<tr class="memdesc:a2ac7fd07dd4ad46d0ecd4a814bed814d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-local instances of <a class="el" href="classspk_1_1IOStream.html" title="An output stream with a custom prefix, suitable for logging or debugging.">IOStream</a> for error output. <br /></td></tr>
<tr class="separator:a2ac7fd07dd4ad46d0ecd4a814bed814d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains the definitions and implementations related to Perlin noise generation. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aed6527896d34c2628aec65a369dee252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6527896d34c2628aec65a369dee252">&#9670;&nbsp;</a></span>InputState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacespk.html#aed6527896d34c2628aec65a369dee252">spk::InputState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The state of an input device like a button or key. </p>
<p>This enum represents the possible states of an input device like a button or a key: Up: The input device is not active. Pressed: The input device just became active. Down: The input device is still active. Released: The input device just became inactive. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aefd0e04975ab0187d20665ab8a864158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd0e04975ab0187d20665ab8a864158">&#9670;&nbsp;</a></span>className() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::className </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prettyFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the class name from the provided pretty function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prettyFunction</td><td>The pretty function string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted class name. </dd></dl>

</div>
</div>
<a id="abfcc5509d013801fd4d0ccf7c64cd83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcc5509d013801fd4d0ccf7c64cd83e">&#9670;&nbsp;</a></span>className() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::className </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>prettyFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the class name from the provided wide string pretty function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prettyFunction</td><td>The wide string pretty function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted class name. </dd></dl>

</div>
</div>
<a id="af1da86df753aa08c134375767f1fd4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1da86df753aa08c134375767f1fd4b1">&#9670;&nbsp;</a></span>getChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t spk::getChar </td>
          <td>(</td>
          <td class="paramtype">std::wfstream &amp;&#160;</td>
          <td class="paramname"><em>p_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a wide character from the provided wide file stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_file</td><td>The wide file stream to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The readed wide character. </dd></dl>

</div>
</div>
<a id="ae9f2918180da54f142029f041b9d1fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f2918180da54f142029f041b9d1fa3">&#9670;&nbsp;</a></span>getStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::getStr </td>
          <td>(</td>
          <td class="paramtype">std::wfstream &amp;&#160;</td>
          <td class="paramname"><em>p_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a wide string from the provided wide file stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_file</td><td>The wide file stream to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The readed wide string. </dd></dl>

</div>
</div>
<a id="a1254ad34752aba2c1362dedb3b3c2175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1254ad34752aba2c1362dedb3b3c2175">&#9670;&nbsp;</a></span>getStringSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::wstring &gt; spk::getStringSplit </td>
          <td>(</td>
          <td class="paramtype">std::wfstream &amp;&#160;</td>
          <td class="paramname"><em>p_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>p_expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and splits a wide string from the provided wide file stream based on the delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_file</td><td>The wide file stream to read from. </td></tr>
    <tr><td class="paramname">p_delim</td><td>The delimiter to split the string. </td></tr>
    <tr><td class="paramname">p_expectedSize</td><td>The expected size of the resulting vector. Default is -1, indicating no specific size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of substrings after splitting. </dd></dl>

</div>
</div>
<a id="acf34a729deb44804d107aef9d2aaad5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf34a729deb44804d107aef9d2aaad5c">&#9670;&nbsp;</a></span>listDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::wstring &gt; spk::listDir </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists all directories in the specified directory path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_path</td><td>The directory path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of directory names. </dd></dl>

</div>
</div>
<a id="a7fcd8e63bed947649a6876dc58f2b51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcd8e63bed947649a6876dc58f2b51c">&#9670;&nbsp;</a></span>listFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::wstring &gt; spk::listFile </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_extension</em> = <code>L&quot;*&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists all files in the specified directory path with the provided extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_path</td><td>The directory path. </td></tr>
    <tr><td class="paramname">p_extension</td><td>The file extension to filter files. Default is "*" (matches all files). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of file names. </dd></dl>

</div>
</div>
<a id="a3bfb867af25d965b131886fe857d23d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfb867af25d965b131886fe857d23d4">&#9670;&nbsp;</a></span>methodName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::methodName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prettyFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the method name from the provided pretty function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prettyFunction</td><td>The pretty function string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted method name. </dd></dl>

</div>
</div>
<a id="a7220789e458bf250bb05472cd28acc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7220789e458bf250bb05472cd28acc6b">&#9670;&nbsp;</a></span>methodName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::methodName </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>prettyFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the method name from the provided wide string pretty function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prettyFunction</td><td>The wide string pretty function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted method name. </dd></dl>

</div>
</div>
<a id="a8cd3e0a18ce342e7152da660662a371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd3e0a18ce342e7152da660662a371d">&#9670;&nbsp;</a></span>numberLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned short spk::numberLength </td>
          <td>(</td>
          <td class="paramtype">NumericType&#160;</td>
          <td class="paramname"><em>p_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the length of a numeric value in a specified base. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumericType</td><td>The type of the numeric value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_number</td><td>The numeric value. </td></tr>
    <tr><td class="paramname">base</td><td>The base in which to calculate the length. Default is 10. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the numeric value. </dd></dl>

</div>
</div>
<a id="adc4d3ecda52ee833bc55ca7ece2f940e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4d3ecda52ee833bc55ca7ece2f940e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; spk::operator* </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the multiplication operator for an arithmetic value and a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the elements of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the arithmetic value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The arithmetic value to be added. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to which the arithmetic value is added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector resulting from the addition. </dd></dl>

</div>
</div>
<a id="a4f95f63066ab643b13ad27871d3a0aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f95f63066ab643b13ad27871d3a0aca">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt;TType&gt; spk::operator* </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded multiplication operator to multiply a value with a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The value to be multiplied. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to multiply the value with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of multiplying the value with the vector. </dd></dl>

</div>
</div>
<a id="ad6c500689e1936587d90db1f1328ceb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c500689e1936587d90db1f1328ceb4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; spk::operator+ </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the addition operator for an arithmetic value and a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the elements of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the arithmetic value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The arithmetic value to be added. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to which the arithmetic value is added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector resulting from the addition. </dd></dl>

</div>
</div>
<a id="a8581e17fe52f716d72b87d12669f7620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8581e17fe52f716d72b87d12669f7620">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt;TType&gt; spk::operator+ </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded addition operator to add a value to a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The value to be added. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to add the value to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of adding the value to the vector. </dd></dl>

</div>
</div>
<a id="a443c70714a630e0cbc2199d56b92cc03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443c70714a630e0cbc2199d56b92cc03">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; spk::operator- </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the substraction operator for an arithmetic value and a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the elements of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the arithmetic value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The arithmetic value to be added. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to which the arithmetic value is added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector resulting from the addition. </dd></dl>

</div>
</div>
<a id="a70753e5aacb8a5eb2f6ae254c139e44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70753e5aacb8a5eb2f6ae254c139e44c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt;TType&gt; spk::operator- </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded subtraction operator to subtract a value from a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The value to be subtracted. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to subtract the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of subtracting the value from the vector. </dd></dl>

</div>
</div>
<a id="a4a8a9957f5dff3695f49beb037108568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8a9957f5dff3695f49beb037108568">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; spk::operator/ </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the division operator for an arithmetic value and a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the elements of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the arithmetic value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The arithmetic value to be added. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to which the arithmetic value is added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector resulting from the addition. </dd></dl>

</div>
</div>
<a id="abc9fb6d5f31677ea83f5e5d3d44c6ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9fb6d5f31677ea83f5e5d3d44c6ed2">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt;TType&gt; spk::operator/ </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded division operator to divide a value by a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The value to be divided. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to divide the value by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of dividing the value by the vector. </dd></dl>

</div>
</div>
<a id="a0f89235a75499ada62763e9d3b2dec82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f89235a75499ada62763e9d3b2dec82">&#9670;&nbsp;</a></span>positiveModulo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">intmax_t spk::positiveModulo </td>
          <td>(</td>
          <td class="paramtype">intmax_t&#160;</td>
          <td class="paramname"><em>p_integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intmax_t&#160;</td>
          <td class="paramname"><em>p_dividor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the positive modulo of the given integer and divisor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_integer</td><td>The integer value. </td></tr>
    <tr><td class="paramname">p_dividor</td><td>The divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The positive modulo result. </dd></dl>

</div>
</div>
<a id="a0c3f970e1658247b9ee9797f18727934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3f970e1658247b9ee9797f18727934">&#9670;&nbsp;</a></span>redirectException()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::redirectException </td>
          <td>(</td>
          <td class="paramtype">std::exception &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring *&#160;</td>
          <td class="paramname"><em>p_jobName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redirect an exception emitted by a thread during the execution of a job. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The orginal exception. </td></tr>
    <tr><td class="paramname">p_jobName</td><td>The name of the job who just thrown an exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e939c5f5ec45c7e93528a983b494a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e939c5f5ec45c7e93528a983b494a0d">&#9670;&nbsp;</a></span>stringSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::wstring &gt; spk::stringSplit </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the input wide string into a vector of substrings based on the provided delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_string</td><td>The input wide string to split. </td></tr>
    <tr><td class="paramname">p_delim</td><td>The delimiter to split the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of substrings after splitting. </dd></dl>

</div>
</div>
<a id="afd100e360a6ec28d27838bedd6167f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd100e360a6ec28d27838bedd6167f02">&#9670;&nbsp;</a></span>throwException()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spk::throwException </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_errorLine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws a runtime_error with the provided error message as wide string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_errorLine</td><td>The error message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#aed6527896d34c2628aec65a369dee252">InputState</a> &amp;&#160;</td>
          <td class="paramname"><em>p_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an InputState value to a string. </p>
<p>This function returns a string representation of an InputState value. This can be useful for debugging or logging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_status</td><td>The InputState value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representation of the InputState value. </dd></dl>

</div>
</div>
<a id="aa420d958f7152d62c0f50b806c26a0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa420d958f7152d62c0f50b806c26a0ff">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a vector to a wstring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_point</td><td>The vector to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting string. </dd></dl>

</div>
</div>
<a id="a49a7d505764b6392380bf9d30d007dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a7d505764b6392380bf9d30d007dba">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a vector to a wstring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_point</td><td>The vector to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting string. </dd></dl>

</div>
</div>
<a id="a98695e9de44684d6aaecc705564cd6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98695e9de44684d6aaecc705564cd6d8">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::wstring &amp; spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28">Keyboard::Key</a> &amp;&#160;</td>
          <td class="paramname"><em>p_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28" title="Enum for representing keyboard keys.">Keyboard::Key</a> to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_key</td><td>The <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28" title="Enum for representing keyboard keys.">Keyboard::Key</a> to convert to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28" title="Enum for representing keyboard keys.">Keyboard::Key</a>. </dd></dl>

</div>
</div>
<a id="a8b0d135246aecf232855d7d804bb55bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0d135246aecf232855d7d804bb55bd">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5">Mouse::Button</a> &amp;&#160;</td>
          <td class="paramname"><em>p_button</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5" title="Enum for mouse buttons.">Mouse::Button</a> value to a wstring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_button</td><td>The <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5" title="Enum for mouse buttons.">Mouse::Button</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5" title="Enum for mouse buttons.">Mouse::Button</a> value. </dd></dl>

</div>
</div>
<a id="a542066c55ed7a3bca5a973af1e8bf8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542066c55ed7a3bca5a973af1e8bf8cd">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1IPerlin.html#a3266c3dd973db71cfd0f81a6b8ff4540">spk::IPerlin::Interpolation</a> &amp;&#160;</td>
          <td class="paramname"><em>p_interpolation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an Interpolation type to a string representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_interpolation</td><td>Interpolation type to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representation of the Interpolation type. </dd></dl>

</div>
</div>
<a id="a736875e1ee6b20eb1e2dd997ba8d354e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736875e1ee6b20eb1e2dd997ba8d354e">&#9670;&nbsp;</a></span>universalCodeDecoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::universalCodeDecoder </td>
          <td>(</td>
          <td class="paramtype">const wchar_t &amp;&#160;</td>
          <td class="paramname"><em>p_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns a non printable or unicode character into its universal code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_code</td><td>A non printable or unicode character. ]0-31[ or ]127-0x10FFFF[ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::wstring A string containing the universal code of the character. (\uXXXX or \uXXXX\uXXXX respectively for 8 or 16 bit characters) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the character is in range ]32-126[, it is returned as is. If the character code is higher than 0x10FFFF, an empty string is returned. </dd></dl>

</div>
</div>
<a id="a6848012087aaf1cc22b17362bd495af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6848012087aaf1cc22b17362bd495af5">&#9670;&nbsp;</a></span>universalCodeEncoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t spk::universalCodeEncoder </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns a universal code into a non printable or unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_code</td><td>The wstring containing the universal code of the character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>wchar_t A non printable or unicode character. ]0-31[ or ]127-0x10FFFF[ </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If your local does not support UTF16, you should use try/catch if you plan to convert or print the result. </dd></dl>

</div>
</div>
<a id="af968ab2db5e30a212aa373cddf7016d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af968ab2db5e30a212aa373cddf7016d5">&#9670;&nbsp;</a></span>wstringToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spk::wstringToString </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_wstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a wide string to a standard string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_wstr</td><td>The wide string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted standard string. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
