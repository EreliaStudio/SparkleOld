<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparkle: spk Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sparkle
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">spk Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains the definitions and implementations related to Perlin noise generation.  
<a href="namespacespk.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1APIModule.html">APIModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing the API interactions.  <a href="classspk_1_1APIModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1GraphicalAPIModule.html">GraphicalAPIModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing the application window.  <a href="classspk_1_1GraphicalAPIModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1KeyboardModule.html">KeyboardModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing the keyboard interactions.  <a href="classspk_1_1KeyboardModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1IMessageConsumerModule.html">IMessageConsumerModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for modules that consume messages.  <a href="classspk_1_1IMessageConsumerModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1MouseModule.html">MouseModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing the mouse interactions.  <a href="classspk_1_1MouseModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ProfilerModule.html">ProfilerModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to profile and manage the frames-per-second rates of the application.  <a href="classspk_1_1ProfilerModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1SystemModule.html">SystemModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing system-level interactions.  <a href="classspk_1_1SystemModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1TimeModule.html">TimeModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing time-related functionality.  <a href="classspk_1_1TimeModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1WidgetModule.html">WidgetModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing widgets within the application.  <a href="classspk_1_1WidgetModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Application.html">Application</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for the application.  <a href="classspk_1_1Application.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html">DataBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing data buffers.  <a href="classspk_1_1DataBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1FieldMap.html">FieldMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Pool.html">Pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class for object pooling.  <a href="classspk_1_1Pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1SafePointer.html">SafePointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for pointers that ensures safer pointer operations.  <a href="classspk_1_1SafePointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Profiler.html">Profiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for profiling various metrics like time consumption and counters.  <a href="classspk_1_1Profiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ActivableObject.html">ActivableObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an activatable object. This class provides functionality to activate and deactivate an object. It also allows adding activation and deactivation callbacks.  <a href="classspk_1_1ActivableObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Activity.html">Activity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an activity. This class defines an activity that can be managed by an ActivityManager. It provides methods for updating, moving to the next step, starting, and checking the status of the activity.  <a href="classspk_1_1Activity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1TimedActivity.html">TimedActivity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an activity that executes a function after a specified delay.  <a href="classspk_1_1TimedActivity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1RetryActivity.html">RetryActivity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an activity that repeatedly executes a function until it returns true.  <a href="classspk_1_1RetryActivity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ActivityScheduler.html">ActivityScheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows activitee to follow each other.  <a href="classspk_1_1ActivityScheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1CommandParser.html">CommandParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classspk_1_1CommandParser.html" title="The CommandParser class is responsible for parsing and processing commands.">CommandParser</a> class is responsible for parsing and processing commands.  <a href="classspk_1_1CommandParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ContextManager.html">ContextManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1ContextManager.html" title="ContextManager is a singleton template class that manages ReadWrite and ReadOnly access to a common c...">ContextManager</a> is a singleton template class that manages ReadWrite and ReadOnly access to a common context.  <a href="classspk_1_1ContextManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ContractProvider.html">ContractProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classspk_1_1ContractProvider_1_1Contract.html" title="Represent the ownership of a callback and allow users to interact with it.">Contract</a> with a callback function and a callbackContainer.  <a href="classspk_1_1ContractProvider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1InherenceObject.html">InherenceObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1InherenceObject.html" title="InherenceObject class template.">InherenceObject</a> class template.  <a href="classspk_1_1InherenceObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Memento.html">Memento</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a memento in the <a class="el" href="classspk_1_1Memento.html" title="A class representing a memento in the Memento design pattern.">Memento</a> design pattern.  <a href="classspk_1_1Memento.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1StandardType.html">StandardType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template for standard layout types, derived from <a class="el" href="classspk_1_1Memento.html" title="A class representing a memento in the Memento design pattern.">Memento</a>.  <a href="structspk_1_1StandardType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ObservableValue.html">ObservableValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class for creating observable values.  <a href="classspk_1_1ObservableValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Observer.html">Observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1Observer.html" title="Observer class template.">Observer</a> class template.  <a href="classspk_1_1Observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Singleton.html">Singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1Singleton.html" title="Singleton class template.">Singleton</a> class template.  <a href="classspk_1_1Singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1StateMachine.html">StateMachine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classspk_1_1StateMachine.html" title="A StateMachine class that handles different state transitions. It allows setting callbacks for state ...">StateMachine</a> class that handles different state transitions. It allows setting callbacks for state transitions and state executions.  <a href="classspk_1_1StateMachine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1StatedObject.html">StatedObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class who manage state switching. This class representing an object who can be in different state. the class additionnaly store lambdas to call uppon specific state. Each lambda is provided to the user as Contract object.  <a href="classspk_1_1StatedObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template for managing a value with default and custom states.  <a href="classspk_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ValueWrapper.html">ValueWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class for managing a value with automatic update notifications.  <a href="classspk_1_1ValueWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Camera.html">Camera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a camera in the Sparkle engine.  <a href="classspk_1_1Camera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Component.html">Component</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a component that can be attached to a <a class="el" href="classspk_1_1GameObject.html" title="Represents a game object in the Sparkle engine.">GameObject</a>.  <a href="classspk_1_1Component.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DirectionalLight.html">DirectionalLight</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a directional light in the scene.  <a href="classspk_1_1DirectionalLight.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1FirstPersonController.html">FirstPersonController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a first-person controller component in the Sparkle engine.  <a href="classspk_1_1FirstPersonController.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1MeshRenderer.html">MeshRenderer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a mesh renderer component in the Sparkle engine.  <a href="classspk_1_1MeshRenderer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Transform.html">Transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the transformation component in the Sparkle engine.  <a href="classspk_1_1Transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1GameEngine.html">GameEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the core game engine in the Sparkle framework.  <a href="classspk_1_1GameEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1GameObject.html">GameObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a game object in the Sparkle engine.  <a href="classspk_1_1GameObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1Material.html">Material</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the material properties of a surface in the rendering engine.  <a href="structspk_1_1Material.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a mesh in the Sparkle engine.  <a href="classspk_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Cube.html">Cube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a cube mesh in the Sparkle engine.  <a href="classspk_1_1Cube.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Frame.html">Frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete implementation of a frame using XCB for Linux platforms.  <a href="classspk_1_1Frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1AbstractFrame.html">AbstractFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for frames.  <a href="classspk_1_1AbstractFrame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Pipeline.html">Pipeline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1AbstractPipeline.html">AbstractPipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for handling different types of shader pipelines.  <a href="classspk_1_1AbstractPipeline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ShaderLayout.html">ShaderLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the layout of a Shader, including its different modules and layouts for various buffer types.  <a href="classspk_1_1ShaderLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ShaderModule.html">ShaderModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader module containing shader instructions.  <a href="classspk_1_1ShaderModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Area.html">Area</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a 2D area in terms of an anchor point and size.  <a href="classspk_1_1Area.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1Color.html">Color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing RGBA color.  <a href="structspk_1_1Color.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Font.html">Font</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a font, which can be used for rendering text.  <a href="classspk_1_1Font.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an image which is a specialized type of texture.  <a href="classspk_1_1Image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1SpriteSheet.html">SpriteSheet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a sprite sheet, derived from an <a class="el" href="classspk_1_1Image.html" title="Represents an image which is a specialized type of texture.">Image</a> class.  <a href="classspk_1_1SpriteSheet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Window.html">Window</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Surface.html">Surface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for creating and managing a GLX-based surface.  <a href="classspk_1_1Surface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1AbstractSurface.html">AbstractSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class representing a surface for rendering.  <a href="classspk_1_1AbstractSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Texture.html">Texture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete implementation of a texture in OpenGL framework.  <a href="classspk_1_1Texture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1AbstractTexture.html">AbstractTexture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an abstract texture in the Sparkle framework. This class serves as the base class for all textures and defines the basic properties and behaviors of a texture.  <a href="classspk_1_1AbstractTexture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Viewport.html">Viewport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete implementation of the <a class="el" href="classspk_1_1AbstractViewport.html" title="An abstract base class for handling viewports within the Sparkle library.">spk::AbstractViewport</a> class.  <a href="classspk_1_1Viewport.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1AbstractViewport.html">AbstractViewport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract base class for handling viewports within the Sparkle library.  <a href="classspk_1_1AbstractViewport.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Input.html">Input</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class providing a common interface for input classes in the 'spk' library.  <a href="classspk_1_1Input.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1InputGroup.html">InputGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a group of input objects.  <a href="classspk_1_1InputGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1KeyInput.html">KeyInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete class derived from <a class="el" href="classspk_1_1Input.html" title="Abstract class providing a common interface for input classes in the &#39;spk&#39; library.">Input</a> that represents keyboard input.  <a href="classspk_1_1KeyInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Keyboard.html">Keyboard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1Singleton.html" title="Singleton class template.">Singleton</a> class for keyboard inputs.  <a href="classspk_1_1Keyboard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Mouse.html">Mouse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspk_1_1Singleton.html" title="Singleton class template.">Singleton</a> class for <a class="el" href="classspk_1_1Mouse.html" title="Singleton class for Mouse.">Mouse</a>.  <a href="classspk_1_1Mouse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1MouseInput.html">MouseInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete class derived from <a class="el" href="classspk_1_1Input.html" title="Abstract class providing a common interface for input classes in the &#39;spk&#39; library.">Input</a> that represents mouse input.  <a href="classspk_1_1MouseInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1MouseMovementInput.html">MouseMovementInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete class derived from <a class="el" href="classspk_1_1Input.html" title="Abstract class providing a common interface for input classes in the &#39;spk&#39; library.">Input</a> that represents mouse movement input.  <a href="classspk_1_1MouseMovementInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1IOStream.html">IOStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream with a custom prefix, suitable for logging or debugging.  <a href="classspk_1_1IOStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1IPerlin.html">IPerlin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functionality related to Perlin noise generation.  <a href="classspk_1_1IPerlin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Perlin1D.html">Perlin1D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Perlin noise generator for one-dimensional input.  <a href="classspk_1_1Perlin1D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Perlin2D.html">Perlin2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Perlin noise generator for two-dimensional input.  <a href="classspk_1_1Perlin2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Perlin3D.html">Perlin3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Perlin noise generator for three-dimensional input.  <a href="classspk_1_1Perlin3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1Matrix4x4.html">Matrix4x4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 4x4 matrix.  <a href="structspk_1_1Matrix4x4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1PseudoRandomGenerator.html">PseudoRandomGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classspk_1_1PseudoRandomGenerator.html" title="The PseudoRandomGenerator class template for generating pseudo random numbers.">PseudoRandomGenerator</a> class template for generating pseudo random numbers.  <a href="classspk_1_1PseudoRandomGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1RandomGenerator.html">RandomGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator template class.  <a href="classspk_1_1RandomGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector2.html">IVector2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A two-dimensional vector class with variable type.  <a href="structspk_1_1IVector2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IVector3.html">IVector3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic 3D vector class template.  <a href="structspk_1_1IVector3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IsContainer.html">IsContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction for checking if a type is a container.  <a href="structspk_1_1IsContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspk_1_1IsContainer_3_01T_00_01std_1_1void__t_3_01decltype_07std_1_1declval_3_01T_01_4_07_091bae1cdb89f7c308b50873cf3c7f724.html">IsContainer&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().begin()), decltype(std::declval&lt; T &gt;().end()), typename T::value_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1TranslationAtlas.html">TranslationAtlas</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to store localized strings.  <a href="classspk_1_1TranslationAtlas.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Chronometer.html">Chronometer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple chronometer class to measure elapsed time.  <a href="classspk_1_1Chronometer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1TimeMetrics.html">TimeMetrics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for recording time-related metrics in the application.  <a href="classspk_1_1TimeMetrics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating and managing a timer.  <a href="classspk_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1PersistentWorker.html">PersistentWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating and managing a persistent worker thread.  <a href="classspk_1_1PersistentWorker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Promise.html">Promise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for providing a promise with a value.  <a href="classspk_1_1Promise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Thread.html">Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating and managing a thread.  <a href="classspk_1_1Thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1ThreadSafeQueue.html">ThreadSafeQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread-safe queue implementation.  <a href="classspk_1_1ThreadSafeQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1WorkerPool.html">WorkerPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating and managing a pool of worker threads.  <a href="classspk_1_1WorkerPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1Worker.html">Worker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating a worker thread.  <a href="classspk_1_1Worker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1GameEngineManager.html">GameEngineManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages and integrates the <a class="el" href="classspk_1_1GameEngine.html" title="Represents the core game engine in the Sparkle framework.">GameEngine</a> with the user interface.  <a href="classspk_1_1GameEngineManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aec5e8bd08055e02d096facc84619ed06"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aec5e8bd08055e02d096facc84619ed06">Scissor</a> = <a class="el" href="classspk_1_1Area.html">Area</a></td></tr>
<tr class="memdesc:aec5e8bd08055e02d096facc84619ed06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classspk_1_1Area.html" title="A class representing a 2D area in terms of an anchor point and size.">Area</a>, used to represent a scissor region for rendering.  <a href="namespacespk.html#aec5e8bd08055e02d096facc84619ed06">More...</a><br /></td></tr>
<tr class="separator:aec5e8bd08055e02d096facc84619ed06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7d33188f36fb94cdde3264ccc16e20"><td class="memItemLeft" align="right" valign="top"><a id="a9b7d33188f36fb94cdde3264ccc16e20"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a9b7d33188f36fb94cdde3264ccc16e20">Vector2</a> = <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; float &gt;</td></tr>
<tr class="memdesc:a9b7d33188f36fb94cdde3264ccc16e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> with float type. <br /></td></tr>
<tr class="separator:a9b7d33188f36fb94cdde3264ccc16e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b9738cf9ec67888207021519d1a673"><td class="memItemLeft" align="right" valign="top"><a id="a81b9738cf9ec67888207021519d1a673"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">Vector2Int</a> = <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; int &gt;</td></tr>
<tr class="memdesc:a81b9738cf9ec67888207021519d1a673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> with int type. <br /></td></tr>
<tr class="separator:a81b9738cf9ec67888207021519d1a673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e1f556496e4d67f41e1f7807069e54"><td class="memItemLeft" align="right" valign="top"><a id="a71e1f556496e4d67f41e1f7807069e54"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a71e1f556496e4d67f41e1f7807069e54">Vector2UInt</a> = <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; unsigned int &gt;</td></tr>
<tr class="memdesc:a71e1f556496e4d67f41e1f7807069e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector2.html" title="A two-dimensional vector class with variable type.">IVector2</a> with unsigned int type. <br /></td></tr>
<tr class="separator:a71e1f556496e4d67f41e1f7807069e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ce29c89e3ca14bf467a94db03d5939"><td class="memItemLeft" align="right" valign="top"><a id="a25ce29c89e3ca14bf467a94db03d5939"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a25ce29c89e3ca14bf467a94db03d5939">Vector3</a> = <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; float &gt;</td></tr>
<tr class="memdesc:a25ce29c89e3ca14bf467a94db03d5939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector3.html" title="A generic 3D vector class template.">IVector3</a> with float type. <br /></td></tr>
<tr class="separator:a25ce29c89e3ca14bf467a94db03d5939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7d4d8007cf977199c3ba89fd52e283"><td class="memItemLeft" align="right" valign="top"><a id="afa7d4d8007cf977199c3ba89fd52e283"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#afa7d4d8007cf977199c3ba89fd52e283">Vector3Int</a> = <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; int &gt;</td></tr>
<tr class="memdesc:afa7d4d8007cf977199c3ba89fd52e283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector3.html" title="A generic 3D vector class template.">IVector3</a> with int type. <br /></td></tr>
<tr class="separator:afa7d4d8007cf977199c3ba89fd52e283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b7e560fadd4adf03bcea8fb62de5a8"><td class="memItemLeft" align="right" valign="top"><a id="aa6b7e560fadd4adf03bcea8fb62de5a8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aa6b7e560fadd4adf03bcea8fb62de5a8">Vector3UInt</a> = <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; unsigned int &gt;</td></tr>
<tr class="memdesc:aa6b7e560fadd4adf03bcea8fb62de5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structspk_1_1IVector3.html" title="A generic 3D vector class template.">IVector3</a> with unsigned int type. <br /></td></tr>
<tr class="separator:aa6b7e560fadd4adf03bcea8fb62de5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63d6b521e49d6b38ad1a1ad57e337a1"><td class="memItemLeft" align="right" valign="top"><a id="ab63d6b521e49d6b38ad1a1ad57e337a1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#ab63d6b521e49d6b38ad1a1ad57e337a1">PlacePixelFunction</a> = std::function&lt; void(std::vector&lt; uint8_t &gt; &amp;, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;, const <a class="el" href="structspk_1_1Font_1_1Key.html">spk::Font::Key</a> &amp;)&gt;</td></tr>
<tr class="memdesc:ab63d6b521e49d6b38ad1a1ad57e337a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for the pixel placement function. <br /></td></tr>
<tr class="separator:ab63d6b521e49d6b38ad1a1ad57e337a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aed6527896d34c2628aec65a369dee252"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aed6527896d34c2628aec65a369dee252">InputState</a> { <b>Up</b>
, <b>Pressed</b>
, <b>Down</b>
, <b>Released</b>
 }</td></tr>
<tr class="memdesc:aed6527896d34c2628aec65a369dee252"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of an input device like a button or key.  <a href="namespacespk.html#aed6527896d34c2628aec65a369dee252">More...</a><br /></td></tr>
<tr class="separator:aed6527896d34c2628aec65a369dee252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a35c88ea124c5bf25cfd51823d719a92b"><td class="memItemLeft" align="right" valign="top">LRESULT CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a35c88ea124c5bf25cfd51823d719a92b">WindowProc</a> (HWND p_hwnd, UINT p_uMsg, WPARAM p_wParam, LPARAM p_lParam)</td></tr>
<tr class="memdesc:a35c88ea124c5bf25cfd51823d719a92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes messages sent to a window.  <a href="namespacespk.html#a35c88ea124c5bf25cfd51823d719a92b">More...</a><br /></td></tr>
<tr class="separator:a35c88ea124c5bf25cfd51823d719a92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b79166d0f6923f9730d6d359d9622b3"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a4b79166d0f6923f9730d6d359d9622b3">to_wstring</a> (const GLenum &amp;p_type)</td></tr>
<tr class="separator:a4b79166d0f6923f9730d6d359d9622b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db08bac60928ed2e27eb9d9f0975591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a4db08bac60928ed2e27eb9d9f0975591">checkOpengl</a> (const std::wstring &amp;msg)</td></tr>
<tr class="separator:a4db08bac60928ed2e27eb9d9f0975591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba">to_wstring</a> (const <a class="el" href="namespacespk.html#aed6527896d34c2628aec65a369dee252">InputState</a> &amp;p_status)</td></tr>
<tr class="memdesc:a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an InputState value to a string.  <a href="namespacespk.html#a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba">More...</a><br /></td></tr>
<tr class="separator:a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98695e9de44684d6aaecc705564cd6d8"><td class="memItemLeft" align="right" valign="top">const std::wstring &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a98695e9de44684d6aaecc705564cd6d8">to_wstring</a> (const <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28">Keyboard::Key</a> &amp;p_key)</td></tr>
<tr class="memdesc:a98695e9de44684d6aaecc705564cd6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28" title="Enum for representing keyboard keys.">Keyboard::Key</a> to a string.  <a href="namespacespk.html#a98695e9de44684d6aaecc705564cd6d8">More...</a><br /></td></tr>
<tr class="separator:a98695e9de44684d6aaecc705564cd6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0d135246aecf232855d7d804bb55bd"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a8b0d135246aecf232855d7d804bb55bd">to_wstring</a> (const <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5">Mouse::Button</a> &amp;p_button)</td></tr>
<tr class="memdesc:a8b0d135246aecf232855d7d804bb55bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5" title="Enum for mouse buttons.">Mouse::Button</a> value to a wstring.  <a href="namespacespk.html#a8b0d135246aecf232855d7d804bb55bd">More...</a><br /></td></tr>
<tr class="separator:a8b0d135246aecf232855d7d804bb55bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542066c55ed7a3bca5a973af1e8bf8cd"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a542066c55ed7a3bca5a973af1e8bf8cd">to_wstring</a> (const <a class="el" href="classspk_1_1IPerlin.html#a3266c3dd973db71cfd0f81a6b8ff4540">spk::IPerlin::Interpolation</a> &amp;p_interpolation)</td></tr>
<tr class="memdesc:a542066c55ed7a3bca5a973af1e8bf8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an Interpolation type to a string representation.  <a href="namespacespk.html#a542066c55ed7a3bca5a973af1e8bf8cd">More...</a><br /></td></tr>
<tr class="separator:a542066c55ed7a3bca5a973af1e8bf8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c500689e1936587d90db1f1328ceb4"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ad6c500689e1936587d90db1f1328ceb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#ad6c500689e1936587d90db1f1328ceb4">operator+</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:ad6c500689e1936587d90db1f1328ceb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the addition operator for an arithmetic value and a vector.  <a href="namespacespk.html#ad6c500689e1936587d90db1f1328ceb4">More...</a><br /></td></tr>
<tr class="separator:ad6c500689e1936587d90db1f1328ceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443c70714a630e0cbc2199d56b92cc03"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a443c70714a630e0cbc2199d56b92cc03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a443c70714a630e0cbc2199d56b92cc03">operator-</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a443c70714a630e0cbc2199d56b92cc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the substraction operator for an arithmetic value and a vector.  <a href="namespacespk.html#a443c70714a630e0cbc2199d56b92cc03">More...</a><br /></td></tr>
<tr class="separator:a443c70714a630e0cbc2199d56b92cc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4d3ecda52ee833bc55ca7ece2f940e"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:adc4d3ecda52ee833bc55ca7ece2f940e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#adc4d3ecda52ee833bc55ca7ece2f940e">operator*</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:adc4d3ecda52ee833bc55ca7ece2f940e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the multiplication operator for an arithmetic value and a vector.  <a href="namespacespk.html#adc4d3ecda52ee833bc55ca7ece2f940e">More...</a><br /></td></tr>
<tr class="separator:adc4d3ecda52ee833bc55ca7ece2f940e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8a9957f5dff3695f49beb037108568"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a4a8a9957f5dff3695f49beb037108568"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a4a8a9957f5dff3695f49beb037108568">operator/</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a4a8a9957f5dff3695f49beb037108568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the division operator for an arithmetic value and a vector.  <a href="namespacespk.html#a4a8a9957f5dff3695f49beb037108568">More...</a><br /></td></tr>
<tr class="separator:a4a8a9957f5dff3695f49beb037108568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa420d958f7152d62c0f50b806c26a0ff"><td class="memTemplParams" colspan="2">template&lt;typename TType &gt; </td></tr>
<tr class="memitem:aa420d958f7152d62c0f50b806c26a0ff"><td class="memTemplItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#aa420d958f7152d62c0f50b806c26a0ff">to_wstring</a> (const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:aa420d958f7152d62c0f50b806c26a0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector to a wstring.  <a href="namespacespk.html#aa420d958f7152d62c0f50b806c26a0ff">More...</a><br /></td></tr>
<tr class="separator:aa420d958f7152d62c0f50b806c26a0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8581e17fe52f716d72b87d12669f7620"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a8581e17fe52f716d72b87d12669f7620"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a8581e17fe52f716d72b87d12669f7620">operator+</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a8581e17fe52f716d72b87d12669f7620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded addition operator to add a value to a vector.  <a href="namespacespk.html#a8581e17fe52f716d72b87d12669f7620">More...</a><br /></td></tr>
<tr class="separator:a8581e17fe52f716d72b87d12669f7620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70753e5aacb8a5eb2f6ae254c139e44c"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a70753e5aacb8a5eb2f6ae254c139e44c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a70753e5aacb8a5eb2f6ae254c139e44c">operator-</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a70753e5aacb8a5eb2f6ae254c139e44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded subtraction operator to subtract a value from a vector.  <a href="namespacespk.html#a70753e5aacb8a5eb2f6ae254c139e44c">More...</a><br /></td></tr>
<tr class="separator:a70753e5aacb8a5eb2f6ae254c139e44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f95f63066ab643b13ad27871d3a0aca"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a4f95f63066ab643b13ad27871d3a0aca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a4f95f63066ab643b13ad27871d3a0aca">operator*</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a4f95f63066ab643b13ad27871d3a0aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded multiplication operator to multiply a value with a vector.  <a href="namespacespk.html#a4f95f63066ab643b13ad27871d3a0aca">More...</a><br /></td></tr>
<tr class="separator:a4f95f63066ab643b13ad27871d3a0aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9fb6d5f31677ea83f5e5d3d44c6ed2"><td class="memTemplParams" colspan="2">template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:abc9fb6d5f31677ea83f5e5d3d44c6ed2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#abc9fb6d5f31677ea83f5e5d3d44c6ed2">operator/</a> (TValueType p_value, const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:abc9fb6d5f31677ea83f5e5d3d44c6ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded division operator to divide a value by a vector.  <a href="namespacespk.html#abc9fb6d5f31677ea83f5e5d3d44c6ed2">More...</a><br /></td></tr>
<tr class="separator:abc9fb6d5f31677ea83f5e5d3d44c6ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a7d505764b6392380bf9d30d007dba"><td class="memTemplParams" colspan="2">template&lt;typename TType &gt; </td></tr>
<tr class="memitem:a49a7d505764b6392380bf9d30d007dba"><td class="memTemplItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a49a7d505764b6392380bf9d30d007dba">to_wstring</a> (const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;p_point)</td></tr>
<tr class="memdesc:a49a7d505764b6392380bf9d30d007dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector to a wstring.  <a href="namespacespk.html#a49a7d505764b6392380bf9d30d007dba">More...</a><br /></td></tr>
<tr class="separator:a49a7d505764b6392380bf9d30d007dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfb867af25d965b131886fe857d23d4"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a3bfb867af25d965b131886fe857d23d4">methodName</a> (const std::string &amp;prettyFunction)</td></tr>
<tr class="memdesc:a3bfb867af25d965b131886fe857d23d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the method name from the provided pretty function.  <a href="namespacespk.html#a3bfb867af25d965b131886fe857d23d4">More...</a><br /></td></tr>
<tr class="separator:a3bfb867af25d965b131886fe857d23d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd0e04975ab0187d20665ab8a864158"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aefd0e04975ab0187d20665ab8a864158">className</a> (const std::string &amp;prettyFunction)</td></tr>
<tr class="memdesc:aefd0e04975ab0187d20665ab8a864158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the class name from the provided pretty function.  <a href="namespacespk.html#aefd0e04975ab0187d20665ab8a864158">More...</a><br /></td></tr>
<tr class="separator:aefd0e04975ab0187d20665ab8a864158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7220789e458bf250bb05472cd28acc6b"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a7220789e458bf250bb05472cd28acc6b">methodName</a> (const std::wstring &amp;prettyFunction)</td></tr>
<tr class="memdesc:a7220789e458bf250bb05472cd28acc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the method name from the provided wide string pretty function.  <a href="namespacespk.html#a7220789e458bf250bb05472cd28acc6b">More...</a><br /></td></tr>
<tr class="separator:a7220789e458bf250bb05472cd28acc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcc5509d013801fd4d0ccf7c64cd83e"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#abfcc5509d013801fd4d0ccf7c64cd83e">className</a> (const std::wstring &amp;prettyFunction)</td></tr>
<tr class="memdesc:abfcc5509d013801fd4d0ccf7c64cd83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the class name from the provided wide string pretty function.  <a href="namespacespk.html#abfcc5509d013801fd4d0ccf7c64cd83e">More...</a><br /></td></tr>
<tr class="separator:abfcc5509d013801fd4d0ccf7c64cd83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e939c5f5ec45c7e93528a983b494a0d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a1e939c5f5ec45c7e93528a983b494a0d">stringSplit</a> (const std::wstring &amp;p_string, const std::wstring &amp;p_delim)</td></tr>
<tr class="memdesc:a1e939c5f5ec45c7e93528a983b494a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the input wide string into a vector of substrings based on the provided delimiter.  <a href="namespacespk.html#a1e939c5f5ec45c7e93528a983b494a0d">More...</a><br /></td></tr>
<tr class="separator:a1e939c5f5ec45c7e93528a983b494a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1da86df753aa08c134375767f1fd4b1"><td class="memItemLeft" align="right" valign="top">wchar_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#af1da86df753aa08c134375767f1fd4b1">getChar</a> (std::wfstream &amp;p_file)</td></tr>
<tr class="memdesc:af1da86df753aa08c134375767f1fd4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a wide character from the provided wide file stream.  <a href="namespacespk.html#af1da86df753aa08c134375767f1fd4b1">More...</a><br /></td></tr>
<tr class="separator:af1da86df753aa08c134375767f1fd4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f2918180da54f142029f041b9d1fa3"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#ae9f2918180da54f142029f041b9d1fa3">getStr</a> (std::wfstream &amp;p_file)</td></tr>
<tr class="memdesc:ae9f2918180da54f142029f041b9d1fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a wide string from the provided wide file stream.  <a href="namespacespk.html#ae9f2918180da54f142029f041b9d1fa3">More...</a><br /></td></tr>
<tr class="separator:ae9f2918180da54f142029f041b9d1fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1254ad34752aba2c1362dedb3b3c2175"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a1254ad34752aba2c1362dedb3b3c2175">getStringSplit</a> (std::wfstream &amp;p_file, const std::wstring &amp;p_delim, const int &amp;p_expectedSize=-1)</td></tr>
<tr class="memdesc:a1254ad34752aba2c1362dedb3b3c2175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and splits a wide string from the provided wide file stream based on the delimiter.  <a href="namespacespk.html#a1254ad34752aba2c1362dedb3b3c2175">More...</a><br /></td></tr>
<tr class="separator:a1254ad34752aba2c1362dedb3b3c2175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fdff4cd71a5dfab09ff2f026a20d97"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aa7fdff4cd71a5dfab09ff2f026a20d97">getFileContent</a> (const std::filesystem::path &amp;p_filePath)</td></tr>
<tr class="memdesc:aa7fdff4cd71a5dfab09ff2f026a20d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the content of a file and returns it as a std::wstring.  <a href="namespacespk.html#aa7fdff4cd71a5dfab09ff2f026a20d97">More...</a><br /></td></tr>
<tr class="separator:aa7fdff4cd71a5dfab09ff2f026a20d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2d076fc9d7a0ac86f30d5b9fb0c8db"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a8e2d076fc9d7a0ac86f30d5b9fb0c8db">getFileContentAsString</a> (const std::filesystem::path &amp;p_filePath)</td></tr>
<tr class="memdesc:a8e2d076fc9d7a0ac86f30d5b9fb0c8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the content of a file and returns it as a std::string.  <a href="namespacespk.html#a8e2d076fc9d7a0ac86f30d5b9fb0c8db">More...</a><br /></td></tr>
<tr class="separator:a8e2d076fc9d7a0ac86f30d5b9fb0c8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f89235a75499ada62763e9d3b2dec82"><td class="memItemLeft" align="right" valign="top">intmax_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a0f89235a75499ada62763e9d3b2dec82">positiveModulo</a> (intmax_t p_integer, intmax_t p_dividor)</td></tr>
<tr class="memdesc:a0f89235a75499ada62763e9d3b2dec82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the positive modulo of the given integer and divisor.  <a href="namespacespk.html#a0f89235a75499ada62763e9d3b2dec82">More...</a><br /></td></tr>
<tr class="separator:a0f89235a75499ada62763e9d3b2dec82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcd8e63bed947649a6876dc58f2b51c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a7fcd8e63bed947649a6876dc58f2b51c">listFile</a> (const std::wstring &amp;p_path, const std::wstring &amp;p_extension=L&quot;*&quot;)</td></tr>
<tr class="memdesc:a7fcd8e63bed947649a6876dc58f2b51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists all files in the specified directory path with the provided extension.  <a href="namespacespk.html#a7fcd8e63bed947649a6876dc58f2b51c">More...</a><br /></td></tr>
<tr class="separator:a7fcd8e63bed947649a6876dc58f2b51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf34a729deb44804d107aef9d2aaad5c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#acf34a729deb44804d107aef9d2aaad5c">listDir</a> (const std::wstring &amp;p_path)</td></tr>
<tr class="memdesc:acf34a729deb44804d107aef9d2aaad5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists all directories in the specified directory path.  <a href="namespacespk.html#acf34a729deb44804d107aef9d2aaad5c">More...</a><br /></td></tr>
<tr class="separator:acf34a729deb44804d107aef9d2aaad5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af968ab2db5e30a212aa373cddf7016d5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#af968ab2db5e30a212aa373cddf7016d5">wstringToString</a> (const std::wstring &amp;p_wstr)</td></tr>
<tr class="memdesc:af968ab2db5e30a212aa373cddf7016d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a wide string to a standard string.  <a href="namespacespk.html#af968ab2db5e30a212aa373cddf7016d5">More...</a><br /></td></tr>
<tr class="separator:af968ab2db5e30a212aa373cddf7016d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd100e360a6ec28d27838bedd6167f02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#afd100e360a6ec28d27838bedd6167f02">throwException</a> (const std::wstring &amp;p_errorLine)</td></tr>
<tr class="memdesc:afd100e360a6ec28d27838bedd6167f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a runtime_error with the provided error message as wide string.  <a href="namespacespk.html#afd100e360a6ec28d27838bedd6167f02">More...</a><br /></td></tr>
<tr class="separator:afd100e360a6ec28d27838bedd6167f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3f970e1658247b9ee9797f18727934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a0c3f970e1658247b9ee9797f18727934">redirectException</a> (std::exception &amp;e, const std::wstring *p_jobName)</td></tr>
<tr class="memdesc:a0c3f970e1658247b9ee9797f18727934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect an exception emitted by a thread during the execution of a job.  <a href="namespacespk.html#a0c3f970e1658247b9ee9797f18727934">More...</a><br /></td></tr>
<tr class="separator:a0c3f970e1658247b9ee9797f18727934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736875e1ee6b20eb1e2dd997ba8d354e"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a736875e1ee6b20eb1e2dd997ba8d354e">universalCodeDecoder</a> (const wchar_t &amp;p_code)</td></tr>
<tr class="memdesc:a736875e1ee6b20eb1e2dd997ba8d354e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns a non printable or unicode character into its universal code.  <a href="namespacespk.html#a736875e1ee6b20eb1e2dd997ba8d354e">More...</a><br /></td></tr>
<tr class="separator:a736875e1ee6b20eb1e2dd997ba8d354e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6848012087aaf1cc22b17362bd495af5"><td class="memItemLeft" align="right" valign="top">wchar_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a6848012087aaf1cc22b17362bd495af5">universalCodeEncoder</a> (const std::wstring &amp;p_code)</td></tr>
<tr class="memdesc:a6848012087aaf1cc22b17362bd495af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns a universal code into a non printable or unicode character.  <a href="namespacespk.html#a6848012087aaf1cc22b17362bd495af5">More...</a><br /></td></tr>
<tr class="separator:a6848012087aaf1cc22b17362bd495af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd3e0a18ce342e7152da660662a371d"><td class="memTemplParams" colspan="2">template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:a8cd3e0a18ce342e7152da660662a371d"><td class="memTemplItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacespk.html#a8cd3e0a18ce342e7152da660662a371d">numberLength</a> (NumericType p_number, unsigned short base=10)</td></tr>
<tr class="memdesc:a8cd3e0a18ce342e7152da660662a371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the length of a numeric value in a specified base.  <a href="namespacespk.html#a8cd3e0a18ce342e7152da660662a371d">More...</a><br /></td></tr>
<tr class="separator:a8cd3e0a18ce342e7152da660662a371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277832439260c3573165da6e04166b9c"><td class="memItemLeft" align="right" valign="top"><a id="a277832439260c3573165da6e04166b9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a277832439260c3573165da6e04166b9c">printCallStack</a> ()</td></tr>
<tr class="memdesc:a277832439260c3573165da6e04166b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the callstack of the current program. <br /></td></tr>
<tr class="separator:a277832439260c3573165da6e04166b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702741bd3d0bcdcccfb8b378c10c8e34"><td class="memItemLeft" align="right" valign="top"><a id="a702741bd3d0bcdcccfb8b378c10c8e34"></a>
std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a702741bd3d0bcdcccfb8b378c10c8e34">to_wstring</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a702741bd3d0bcdcccfb8b378c10c8e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a wstring. <br /></td></tr>
<tr class="separator:a702741bd3d0bcdcccfb8b378c10c8e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb349b37a810952084392e9c7cc6f14"><td class="memItemLeft" align="right" valign="top"><a id="aafb349b37a810952084392e9c7cc6f14"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aafb349b37a810952084392e9c7cc6f14">getLastSocketErrorValue</a> ()</td></tr>
<tr class="memdesc:aafb349b37a810952084392e9c7cc6f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last error generated by the socket manager. <br /></td></tr>
<tr class="separator:aafb349b37a810952084392e9c7cc6f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5d866254b21d59e02bb19bbacbe783"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#afd5d866254b21d59e02bb19bbacbe783">degreeToRadian</a> (float degrees)</td></tr>
<tr class="memdesc:afd5d866254b21d59e02bb19bbacbe783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts degrees to radians.  <a href="namespacespk.html#afd5d866254b21d59e02bb19bbacbe783">More...</a><br /></td></tr>
<tr class="separator:afd5d866254b21d59e02bb19bbacbe783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef69d819e47992e44a46c974ced8322c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aef69d819e47992e44a46c974ced8322c">radianToDegree</a> (float radians)</td></tr>
<tr class="memdesc:aef69d819e47992e44a46c974ced8322c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts radians to degrees.  <a href="namespacespk.html#aef69d819e47992e44a46c974ced8322c">More...</a><br /></td></tr>
<tr class="separator:aef69d819e47992e44a46c974ced8322c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92466c12bd737c972d2f98d26a307002"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a92466c12bd737c972d2f98d26a307002">_placePixelManhattan</a> (std::vector&lt; uint8_t &gt; &amp;p_atlasData, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_atlasSize, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_pixelOrigin, const int &amp;p_x, const int &amp;p_y, const <a class="el" href="structspk_1_1Font_1_1Key.html">spk::Font::Key</a> &amp;p_key)</td></tr>
<tr class="memdesc:a92466c12bd737c972d2f98d26a307002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a pixel using the Manhattan distance metric.  <a href="namespacespk.html#a92466c12bd737c972d2f98d26a307002">More...</a><br /></td></tr>
<tr class="separator:a92466c12bd737c972d2f98d26a307002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8332e2fb7eb3494b2748596e2b358ab1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a8332e2fb7eb3494b2748596e2b358ab1">_placePixelPixelized</a> (std::vector&lt; uint8_t &gt; &amp;p_atlasData, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_atlasSize, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_pixelOrigin, const int &amp;p_x, const int &amp;p_y, const <a class="el" href="structspk_1_1Font_1_1Key.html">spk::Font::Key</a> &amp;p_key)</td></tr>
<tr class="memdesc:a8332e2fb7eb3494b2748596e2b358ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a pixel using a pixelized outline method.  <a href="namespacespk.html#a8332e2fb7eb3494b2748596e2b358ab1">More...</a><br /></td></tr>
<tr class="separator:a8332e2fb7eb3494b2748596e2b358ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b5f8a778dfef01dc91b1f96a9282df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a75b5f8a778dfef01dc91b1f96a9282df">_placePixelSharpEdge</a> (std::vector&lt; uint8_t &gt; &amp;p_atlasData, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_atlasSize, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_pixelOrigin, const int &amp;p_x, const int &amp;p_y, const <a class="el" href="structspk_1_1Font_1_1Key.html">spk::Font::Key</a> &amp;p_key)</td></tr>
<tr class="memdesc:a75b5f8a778dfef01dc91b1f96a9282df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a pixel using a sharp edge outline method.  <a href="namespacespk.html#a75b5f8a778dfef01dc91b1f96a9282df">More...</a><br /></td></tr>
<tr class="separator:a75b5f8a778dfef01dc91b1f96a9282df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ab4a329dcbffca5372afe326dcee8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a16ab4a329dcbffca5372afe326dcee8a">_placePixelStandard</a> (std::vector&lt; uint8_t &gt; &amp;p_atlasData, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_atlasSize, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_pixelOrigin, const int &amp;p_x, const int &amp;p_y, const <a class="el" href="structspk_1_1Font_1_1Key.html">spk::Font::Key</a> &amp;p_key)</td></tr>
<tr class="memdesc:a16ab4a329dcbffca5372afe326dcee8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a pixel using the standard method to create a "circle" shape outline.  <a href="namespacespk.html#a16ab4a329dcbffca5372afe326dcee8a">More...</a><br /></td></tr>
<tr class="separator:a16ab4a329dcbffca5372afe326dcee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadee2839be43550ad22033f6377e44ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aadee2839be43550ad22033f6377e44ca">_applyOutline</a> (std::vector&lt; uint8_t &gt; &amp;p_atlasData, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_atlasSize, const <a class="el" href="structspk_1_1Font_1_1Key.html">spk::Font::Key</a> &amp;p_key)</td></tr>
<tr class="memdesc:aadee2839be43550ad22033f6377e44ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the appropriate outline to the atlas data.  <a href="namespacespk.html#aadee2839be43550ad22033f6377e44ca">More...</a><br /></td></tr>
<tr class="separator:aadee2839be43550ad22033f6377e44ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352cb854f100b6c2704d2e2563aba99d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a352cb854f100b6c2704d2e2563aba99d">_normalizeAtlasData</a> (std::vector&lt; uint8_t &gt; &amp;p_atlasData, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_atlasSize)</td></tr>
<tr class="memdesc:a352cb854f100b6c2704d2e2563aba99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the atlas data.  <a href="namespacespk.html#a352cb854f100b6c2704d2e2563aba99d">More...</a><br /></td></tr>
<tr class="separator:a352cb854f100b6c2704d2e2563aba99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46118152ba4567548dc43b532ffab28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacespk.html#ab63d6b521e49d6b38ad1a1ad57e337a1">PlacePixelFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#ad46118152ba4567548dc43b532ffab28">_requestPlacePixelFunction</a> (const <a class="el" href="classspk_1_1Font.html#ad6aea176b2688e771c0b34525a12bdc8">spk::Font::OutlineType</a> &amp;p_outlineType)</td></tr>
<tr class="memdesc:ad46118152ba4567548dc43b532ffab28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the appropriate pixel placement function based on outline type.  <a href="namespacespk.html#ad46118152ba4567548dc43b532ffab28">More...</a><br /></td></tr>
<tr class="separator:ad46118152ba4567548dc43b532ffab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c075624391b67fe4d2d404f33fc417b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a6c075624391b67fe4d2d404f33fc417b">_isPixelOnBorder</a> (std::vector&lt; uint8_t &gt; &amp;p_atlasData, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_atlasSize, const size_t &amp;p_index)</td></tr>
<tr class="memdesc:a6c075624391b67fe4d2d404f33fc417b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a pixel is on the border.  <a href="namespacespk.html#a6c075624391b67fe4d2d404f33fc417b">More...</a><br /></td></tr>
<tr class="separator:a6c075624391b67fe4d2d404f33fc417b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cef1352a23500e75882be52c79c066"><td class="memItemLeft" align="right" valign="top">std::vector&lt; wchar_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a88cef1352a23500e75882be52c79c066">getCodepointsInFont</a> (const stbtt_fontinfo *p_fontInfo)</td></tr>
<tr class="memdesc:a88cef1352a23500e75882be52c79c066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the codepoints present in the font.  <a href="namespacespk.html#a88cef1352a23500e75882be52c79c066">More...</a><br /></td></tr>
<tr class="separator:a88cef1352a23500e75882be52c79c066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64b6ff104b5b8cd0be0be5eca21ca27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aa64b6ff104b5b8cd0be0be5eca21ca27">_executePackingOperation</a> (const std::vector&lt; uint8_t &gt; &amp;p_fontData, const <a class="el" href="structspk_1_1Font_1_1Configuration.html">Font::Configuration</a> &amp;p_fontConfiguration, const <a class="el" href="structspk_1_1Font_1_1Key.html">Font::Key</a> &amp;p_key, std::vector&lt; uint8_t &gt; &amp;atlasData, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;atlasSize, stbtt_packedchar *charInformation)</td></tr>
<tr class="memdesc:aa64b6ff104b5b8cd0be0be5eca21ca27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the packing operation for the font.  <a href="namespacespk.html#aa64b6ff104b5b8cd0be0be5eca21ca27">More...</a><br /></td></tr>
<tr class="separator:aa64b6ff104b5b8cd0be0be5eca21ca27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdb6e3348d356301ee725ffcf61d1ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#abcdb6e3348d356301ee725ffcf61d1ce">_computeCharGlyphData</a> (const wchar_t &amp;p_char, <a class="el" href="structspk_1_1Font_1_1Atlas_1_1GlyphData.html">spk::Font::Atlas::GlyphData</a> &amp;p_data, const stbtt_packedchar *p_charInformation, const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;p_atlasSize, const <a class="el" href="namespacespk.html#a9b7d33188f36fb94cdde3264ccc16e20">spk::Vector2</a> &amp;outlineOffset)</td></tr>
<tr class="memdesc:abcdb6e3348d356301ee725ffcf61d1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes glyph data for a character.  <a href="namespacespk.html#abcdb6e3348d356301ee725ffcf61d1ce">More...</a><br /></td></tr>
<tr class="separator:abcdb6e3348d356301ee725ffcf61d1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5871b92a2419c920588de2f0449fa6"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a2a5871b92a2419c920588de2f0449fa6">operator&lt;&lt;</a> (std::wostream &amp;p_out, const <a class="el" href="classspk_1_1ShaderLayout.html">ShaderLayout</a> &amp;p_config)</td></tr>
<tr class="separator:a2a5871b92a2419c920588de2f0449fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7677e8cb7ce3ffdce0ae61d53b1c1"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a0af7677e8cb7ce3ffdce0ae61d53b1c1">operator&lt;&lt;</a> (std::wostream &amp;p_out, const <a class="el" href="structspk_1_1ShaderLayout_1_1Data.html#a5ca25000be7263653c0d234587ca1539">ShaderLayout::Data::Type</a> &amp;p_type)</td></tr>
<tr class="separator:a0af7677e8cb7ce3ffdce0ae61d53b1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767f427d0bb2fa60e359bd675906da25"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a767f427d0bb2fa60e359bd675906da25">operator&lt;&lt;</a> (std::wostream &amp;p_out, const <a class="el" href="structspk_1_1ShaderLayout_1_1Data.html">ShaderLayout::Data</a> &amp;p_data)</td></tr>
<tr class="separator:a767f427d0bb2fa60e359bd675906da25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd33df9019cf4c85fab84cb702b30d6"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a5cd33df9019cf4c85fab84cb702b30d6">operator&lt;&lt;</a> (std::wostream &amp;p_out, const <a class="el" href="structspk_1_1ShaderLayout_1_1FieldArrayLayout_1_1Field.html">ShaderLayout::FieldArrayLayout::Field</a> &amp;p_field)</td></tr>
<tr class="separator:a5cd33df9019cf4c85fab84cb702b30d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc569ea956f7ba847cf5560f1ebd810a"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#abc569ea956f7ba847cf5560f1ebd810a">operator&lt;&lt;</a> (std::wostream &amp;p_out, const <a class="el" href="classspk_1_1ShaderLayout_1_1FieldArrayLayout.html">ShaderLayout::FieldArrayLayout</a> &amp;p_layout)</td></tr>
<tr class="separator:abc569ea956f7ba847cf5560f1ebd810a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb5801f7bcf70cc6b726033f9ff429c"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#addb5801f7bcf70cc6b726033f9ff429c">operator&lt;&lt;</a> (std::wostream &amp;p_out, const <a class="el" href="classspk_1_1ShaderLayout_1_1PushConstantsLayout.html">ShaderLayout::PushConstantsLayout</a> &amp;p_layout)</td></tr>
<tr class="separator:addb5801f7bcf70cc6b726033f9ff429c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da50a9ba3d3e85ca37ca8b78d0ce7c0"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a0da50a9ba3d3e85ca37ca8b78d0ce7c0">operator&lt;&lt;</a> (std::wostream &amp;p_out, const <a class="el" href="classspk_1_1ShaderLayout_1_1StructureLayout.html">ShaderLayout::StructureLayout</a> &amp;p_layout)</td></tr>
<tr class="separator:a0da50a9ba3d3e85ca37ca8b78d0ce7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9599eec12355d40afbb699f241458cd4"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a9599eec12355d40afbb699f241458cd4">operator&lt;&lt;</a> (std::wostream &amp;p_os, const <a class="el" href="structspk_1_1ShaderModule_1_1Instruction.html#ad56deea84138da71568fd38db90b5d34">ShaderModule::Instruction::Type</a> &amp;p_type)</td></tr>
<tr class="separator:a9599eec12355d40afbb699f241458cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accca98d92e095c0e4bac94f5c8bad561"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#accca98d92e095c0e4bac94f5c8bad561">findFirstBindingAvailable</a> (const <a class="el" href="classspk_1_1ShaderLayout.html">spk::ShaderLayout</a> &amp;p_shaderLayout)</td></tr>
<tr class="memdesc:accca98d92e095c0e4bac94f5c8bad561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first available binding slot for a UniformBlock in a given <a class="el" href="classspk_1_1ShaderLayout.html" title="Handles the layout of a Shader, including its different modules and layouts for various buffer types.">ShaderLayout</a>.  <a href="namespacespk.html#accca98d92e095c0e4bac94f5c8bad561">More...</a><br /></td></tr>
<tr class="separator:accca98d92e095c0e4bac94f5c8bad561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75635745fccbb641f55a9c9fcaa9829"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aa75635745fccbb641f55a9c9fcaa9829">compileShaderModule</a> (GLuint p_shaderIndex, std::string p_shaderName, std::string p_shaderCode)</td></tr>
<tr class="separator:aa75635745fccbb641f55a9c9fcaa9829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbffd7fee4d12e48cbc514119c29092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a1fbffd7fee4d12e48cbc514119c29092">compileProgram</a> (GLuint p_programID, GLuint p_vertexID, GLuint p_fragmentID)</td></tr>
<tr class="separator:a1fbffd7fee4d12e48cbc514119c29092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d37acf3a4bdcd511bd06ceec8687ff3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a7d37acf3a4bdcd511bd06ceec8687ff3">convertCodeToOpenGL</a> (const <a class="el" href="classspk_1_1ShaderLayout.html">spk::ShaderLayout</a> &amp;p_shaderLayout, const std::string &amp;p_code)</td></tr>
<tr class="memdesc:a7d37acf3a4bdcd511bd06ceec8687ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts shader code from Vulkan to OpenGL by replacing specific layout qualifiers.  <a href="namespacespk.html#a7d37acf3a4bdcd511bd06ceec8687ff3">More...</a><br /></td></tr>
<tr class="separator:a7d37acf3a4bdcd511bd06ceec8687ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacba30e91fdc2a6f20d31e9fdbb6c059"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aacba30e91fdc2a6f20d31e9fdbb6c059">operator&lt;&lt;</a> (std::wostream &amp;p_os, const <a class="el" href="structspk_1_1Color.html">Color</a> &amp;p_values)</td></tr>
<tr class="separator:aacba30e91fdc2a6f20d31e9fdbb6c059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42089d77d552f96126d09785e491a5e6"><td class="memItemLeft" align="right" valign="top">void GLAPIENTRY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a42089d77d552f96126d09785e491a5e6">MessageOpenGLCallback</a> (GLenum p_source, GLenum p_type, GLuint p_id, GLenum p_severity, GLsizei p_length, const GLchar *p_message, const void *p_userParam)</td></tr>
<tr class="memdesc:a42089d77d552f96126d09785e491a5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL debug callback function to handle and log runtime messages.  <a href="namespacespk.html#a42089d77d552f96126d09785e491a5e6">More...</a><br /></td></tr>
<tr class="separator:a42089d77d552f96126d09785e491a5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393c9bb05e2e511f137bbd97f7b1da06"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a393c9bb05e2e511f137bbd97f7b1da06">toOpenGLFormat</a> (const <a class="el" href="classspk_1_1AbstractTexture.html#a8668b8e9dc849296ba3d07aa641007a6">AbstractTexture::Format</a> &amp;p_format)</td></tr>
<tr class="memdesc:a393c9bb05e2e511f137bbd97f7b1da06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Sparkle texture format to its equivalent OpenGL format.  <a href="namespacespk.html#a393c9bb05e2e511f137bbd97f7b1da06">More...</a><br /></td></tr>
<tr class="separator:a393c9bb05e2e511f137bbd97f7b1da06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa050ad5cd7dd01953b53b0d775890f0e"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#aa050ad5cd7dd01953b53b0d775890f0e">toOpenGLFiltering</a> (const <a class="el" href="classspk_1_1AbstractTexture.html#a787fcde7373f2fc8ce0963ced09de4e2">AbstractTexture::Filtering</a> &amp;p_filtering)</td></tr>
<tr class="memdesc:aa050ad5cd7dd01953b53b0d775890f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Sparkle texture filtering type to its equivalent OpenGL filtering type.  <a href="namespacespk.html#aa050ad5cd7dd01953b53b0d775890f0e">More...</a><br /></td></tr>
<tr class="separator:aa050ad5cd7dd01953b53b0d775890f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3397242821cdec550b7e33af76623f"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a0b3397242821cdec550b7e33af76623f">toOpenGLWrap</a> (const <a class="el" href="classspk_1_1AbstractTexture.html#a51404e7a46755485f8c548db2af49e1f">AbstractTexture::Wrap</a> &amp;p_wrap)</td></tr>
<tr class="memdesc:a0b3397242821cdec550b7e33af76623f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Sparkle texture wrapping mode to its equivalent OpenGL wrapping mode.  <a href="namespacespk.html#a0b3397242821cdec550b7e33af76623f">More...</a><br /></td></tr>
<tr class="separator:a0b3397242821cdec550b7e33af76623f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508ccf4cd36f6ce464d8b4016fdedb9a"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a508ccf4cd36f6ce464d8b4016fdedb9a">operator&lt;&lt;</a> (std::wostream &amp;p_os, const <a class="el" href="classspk_1_1AbstractTexture.html#a8668b8e9dc849296ba3d07aa641007a6">AbstractTexture::Format</a> &amp;p_format)</td></tr>
<tr class="memdesc:a508ccf4cd36f6ce464d8b4016fdedb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the insertion operator for <a class="el" href="classspk_1_1AbstractTexture.html#a8668b8e9dc849296ba3d07aa641007a6" title="Texture formats. Defines the different color channels a texture can have.">AbstractTexture::Format</a>. This allows printing of Format enum values to a wide output stream in a human-readable format.  <a href="namespacespk.html#a508ccf4cd36f6ce464d8b4016fdedb9a">More...</a><br /></td></tr>
<tr class="separator:a508ccf4cd36f6ce464d8b4016fdedb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14952c18111b1dbd754b3609c923259f"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a14952c18111b1dbd754b3609c923259f">operator&lt;&lt;</a> (std::wostream &amp;p_os, const <a class="el" href="classspk_1_1AbstractTexture.html#a787fcde7373f2fc8ce0963ced09de4e2">AbstractTexture::Filtering</a> &amp;p_filtering)</td></tr>
<tr class="memdesc:a14952c18111b1dbd754b3609c923259f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the insertion operator for <a class="el" href="classspk_1_1AbstractTexture.html#a787fcde7373f2fc8ce0963ced09de4e2" title="Texture filtering options. Defines the various filtering methods that can be applied when sampling th...">AbstractTexture::Filtering</a>. This allows printing of Filtering enum values to a wide output stream in a human-readable format.  <a href="namespacespk.html#a14952c18111b1dbd754b3609c923259f">More...</a><br /></td></tr>
<tr class="separator:a14952c18111b1dbd754b3609c923259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc51ec58cbafb68ae53080379e035741"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#afc51ec58cbafb68ae53080379e035741">operator&lt;&lt;</a> (std::wostream &amp;p_os, const <a class="el" href="classspk_1_1AbstractTexture.html#a51404e7a46755485f8c548db2af49e1f">AbstractTexture::Wrap</a> &amp;p_wrap)</td></tr>
<tr class="memdesc:afc51ec58cbafb68ae53080379e035741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the insertion operator for <a class="el" href="classspk_1_1AbstractTexture.html#a51404e7a46755485f8c548db2af49e1f" title="Texture wrapping modes. Defines how the texture behaves when sampled outside the [0,...">AbstractTexture::Wrap</a>. This allows printing of Wrap enum values to a wide output stream in a human-readable format.  <a href="namespacespk.html#afc51ec58cbafb68ae53080379e035741">More...</a><br /></td></tr>
<tr class="separator:afc51ec58cbafb68ae53080379e035741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcfc3bc2aba3f10502336996c4470cc"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a3bcfc3bc2aba3f10502336996c4470cc">operator&lt;&lt;</a> (std::wostream &amp;p_os, const <a class="el" href="classspk_1_1AbstractTexture.html#a025d98644a7d454c27d865572014e031">AbstractTexture::Mipmap</a> &amp;p_mipmap)</td></tr>
<tr class="memdesc:a3bcfc3bc2aba3f10502336996c4470cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the insertion operator for <a class="el" href="classspk_1_1AbstractTexture.html#a025d98644a7d454c27d865572014e031" title="Mipmap settings for textures. Defines whether mipmaps should be used for the texture.">AbstractTexture::Mipmap</a>. This allows printing of Mipmap enum values to a wide output stream in a human-readable format.  <a href="namespacespk.html#a3bcfc3bc2aba3f10502336996c4470cc">More...</a><br /></td></tr>
<tr class="separator:a3bcfc3bc2aba3f10502336996c4470cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7a6a5cbca57b40e3f41c1c143eb09680"><td class="memItemLeft" align="right" valign="top"><a id="a7a6a5cbca57b40e3f41c1c143eb09680"></a>
thread_local <a class="el" href="classspk_1_1IOStream.html">spk::IOStream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a7a6a5cbca57b40e3f41c1c143eb09680">cout</a> = <a class="el" href="classspk_1_1IOStream.html">IOStream</a>(std::wcout)</td></tr>
<tr class="memdesc:a7a6a5cbca57b40e3f41c1c143eb09680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-local instances of <a class="el" href="classspk_1_1IOStream.html" title="An output stream with a custom prefix, suitable for logging or debugging.">IOStream</a> for standard output. <br /></td></tr>
<tr class="separator:a7a6a5cbca57b40e3f41c1c143eb09680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac7fd07dd4ad46d0ecd4a814bed814d"><td class="memItemLeft" align="right" valign="top"><a id="a2ac7fd07dd4ad46d0ecd4a814bed814d"></a>
thread_local <a class="el" href="classspk_1_1IOStream.html">spk::IOStream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacespk.html#a2ac7fd07dd4ad46d0ecd4a814bed814d">cerr</a> = <a class="el" href="classspk_1_1IOStream.html">IOStream</a>(std::wcerr)</td></tr>
<tr class="memdesc:a2ac7fd07dd4ad46d0ecd4a814bed814d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-local instances of <a class="el" href="classspk_1_1IOStream.html" title="An output stream with a custom prefix, suitable for logging or debugging.">IOStream</a> for error output. <br /></td></tr>
<tr class="separator:a2ac7fd07dd4ad46d0ecd4a814bed814d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains the definitions and implementations related to Perlin noise generation. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aec5e8bd08055e02d096facc84619ed06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5e8bd08055e02d096facc84619ed06">&#9670;&nbsp;</a></span>Scissor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacespk.html#aec5e8bd08055e02d096facc84619ed06">spk::Scissor</a> = typedef <a class="el" href="classspk_1_1Area.html">Area</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="classspk_1_1Area.html" title="A class representing a 2D area in terms of an anchor point and size.">Area</a>, used to represent a scissor region for rendering. </p>
<p>The Scissor is a rectangular area where rendering will be limited to. Outside this area, no pixels will be affected. It also uses an anchor point and a size. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aed6527896d34c2628aec65a369dee252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6527896d34c2628aec65a369dee252">&#9670;&nbsp;</a></span>InputState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacespk.html#aed6527896d34c2628aec65a369dee252">spk::InputState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The state of an input device like a button or key. </p>
<p>This enum represents the possible states of an input device like a button or a key: Up: The input device is not active. Pressed: The input device just became active. Down: The input device is still active. Released: The input device just became inactive. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aadee2839be43550ad22033f6377e44ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadee2839be43550ad22033f6377e44ca">&#9670;&nbsp;</a></span>_applyOutline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::_applyOutline </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_atlasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_atlasSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1Font_1_1Key.html">spk::Font::Key</a> &amp;&#160;</td>
          <td class="paramname"><em>p_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the appropriate outline to the atlas data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_atlasData</td><td>The atlas data. </td></tr>
    <tr><td class="paramname">p_atlasSize</td><td>Size of the atlas. </td></tr>
    <tr><td class="paramname">p_key</td><td><a class="el" href="classspk_1_1Font.html" title="Represents a font, which can be used for rendering text.">Font</a> key information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcdb6e3348d356301ee725ffcf61d1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdb6e3348d356301ee725ffcf61d1ce">&#9670;&nbsp;</a></span>_computeCharGlyphData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::_computeCharGlyphData </td>
          <td>(</td>
          <td class="paramtype">const wchar_t &amp;&#160;</td>
          <td class="paramname"><em>p_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspk_1_1Font_1_1Atlas_1_1GlyphData.html">spk::Font::Atlas::GlyphData</a> &amp;&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stbtt_packedchar *&#160;</td>
          <td class="paramname"><em>p_charInformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_atlasSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a9b7d33188f36fb94cdde3264ccc16e20">spk::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>outlineOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes glyph data for a character. </p>
<p>Using the packed character information, this function extracts the UVs and positions for the character's glyph, considering an outline offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_char</td><td>The character for which the glyph data is needed. </td></tr>
    <tr><td class="paramname">p_data</td><td>The resulting glyph data. </td></tr>
    <tr><td class="paramname">p_charInformation</td><td>The packed character information. </td></tr>
    <tr><td class="paramname">p_atlasSize</td><td>The dimensions of the atlas. </td></tr>
    <tr><td class="paramname">outlineOffset</td><td>The offset for the outline. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa64b6ff104b5b8cd0be0be5eca21ca27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64b6ff104b5b8cd0be0be5eca21ca27">&#9670;&nbsp;</a></span>_executePackingOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spk::_executePackingOperation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_fontData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1Font_1_1Configuration.html">Font::Configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>p_fontConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1Font_1_1Key.html">Font::Key</a> &amp;&#160;</td>
          <td class="paramname"><em>p_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>atlasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>atlasSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stbtt_packedchar *&#160;</td>
          <td class="paramname"><em>charInformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the packing operation for the font. </p>
<p>Uses stbtt to pack the glyphs of a font into an atlas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_fontData</td><td>The font data vector. </td></tr>
    <tr><td class="paramname">p_fontConfiguration</td><td>The font configuration. </td></tr>
    <tr><td class="paramname">p_key</td><td>The key which defines the font characteristics. </td></tr>
    <tr><td class="paramname">atlasData</td><td>The resulting atlas data after packing. </td></tr>
    <tr><td class="paramname">atlasSize</td><td>The dimensions of the atlas. </td></tr>
    <tr><td class="paramname">charInformation</td><td>The packed character information after packing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the packing operation is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a6c075624391b67fe4d2d404f33fc417b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c075624391b67fe4d2d404f33fc417b">&#9670;&nbsp;</a></span>_isPixelOnBorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spk::_isPixelOnBorder </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_atlasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_atlasSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>p_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a pixel is on the border. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_atlasData</td><td>The atlas data. </td></tr>
    <tr><td class="paramname">p_atlasSize</td><td>Size of the atlas. </td></tr>
    <tr><td class="paramname">p_index</td><td>Index of the pixel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the pixel is on the border, false otherwise. </dd></dl>

</div>
</div>
<a id="a352cb854f100b6c2704d2e2563aba99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352cb854f100b6c2704d2e2563aba99d">&#9670;&nbsp;</a></span>_normalizeAtlasData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::_normalizeAtlasData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_atlasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_atlasSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the atlas data. </p>
<p>This function iterates through all pixels in the atlas and normalizes their values. Any pixel not representing a character (<code><a class="el" href="classspk_1_1Font.html#a819bd90bab55e93ef265a008821fa47a" title="Pixel value representing a character in the font texture.">Font::CHAR_PIXEL</a></code>) is set to be empty (<code><a class="el" href="classspk_1_1Font.html#ae48e8b73f43bfc181a1f9362ef3e759a" title="Pixel value representing empty space in the font texture.">Font::EMPTY_PIXEL</a></code>). Pixels representing characters remain unchanged. This ensures the atlas data contains only distinct values corresponding to character pixels and empty pixels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_atlasData</td><td>The atlas data where pixels are stored. </td></tr>
    <tr><td class="paramname">p_atlasSize</td><td>The dimensions of the atlas. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92466c12bd737c972d2f98d26a307002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92466c12bd737c972d2f98d26a307002">&#9670;&nbsp;</a></span>_placePixelManhattan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::_placePixelManhattan </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_atlasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_atlasSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_pixelOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>p_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>p_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1Font_1_1Key.html">spk::Font::Key</a> &amp;&#160;</td>
          <td class="paramname"><em>p_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a pixel using the Manhattan distance metric. </p>
<p>This function modifies the atlas data based on the Manhattan distance from a given pixel. It inspects adjacent pixels and updates their values according to the Manhattan distance calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_atlasData</td><td>The atlas data where pixels are stored. </td></tr>
    <tr><td class="paramname">p_atlasSize</td><td>The dimensions of the atlas. </td></tr>
    <tr><td class="paramname">p_pixelOrigin</td><td>The origin of the pixel (usually its top-left corner). </td></tr>
    <tr><td class="paramname">p_x</td><td>The x-coordinate of the current pixel. </td></tr>
    <tr><td class="paramname">p_y</td><td>The y-coordinate of the current pixel. </td></tr>
    <tr><td class="paramname">p_key</td><td><a class="el" href="classspk_1_1Font.html" title="Represents a font, which can be used for rendering text.">Font</a> key containing information like outline size, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8332e2fb7eb3494b2748596e2b358ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8332e2fb7eb3494b2748596e2b358ab1">&#9670;&nbsp;</a></span>_placePixelPixelized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::_placePixelPixelized </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_atlasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_atlasSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_pixelOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>p_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>p_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1Font_1_1Key.html">spk::Font::Key</a> &amp;&#160;</td>
          <td class="paramname"><em>p_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a pixel using a pixelized outline method. </p>
<p>This function modifies the atlas data to apply a pixelized outline around characters. It updates pixel values based on their distance from the base pixel and their alignment with the original pixel of the font, creating a blocky appearance characteristic of pixelized fonts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_atlasData</td><td>The atlas data where pixels are stored. </td></tr>
    <tr><td class="paramname">p_atlasSize</td><td>The dimensions of the atlas. </td></tr>
    <tr><td class="paramname">p_pixelOrigin</td><td>The origin of the pixel (usually its top-left corner). </td></tr>
    <tr><td class="paramname">p_x</td><td>The x-coordinate of the current pixel. </td></tr>
    <tr><td class="paramname">p_y</td><td>The y-coordinate of the current pixel. </td></tr>
    <tr><td class="paramname">p_key</td><td><a class="el" href="classspk_1_1Font.html" title="Represents a font, which can be used for rendering text.">Font</a> key containing information like outline size, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75b5f8a778dfef01dc91b1f96a9282df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b5f8a778dfef01dc91b1f96a9282df">&#9670;&nbsp;</a></span>_placePixelSharpEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::_placePixelSharpEdge </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_atlasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_atlasSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_pixelOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>p_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>p_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1Font_1_1Key.html">spk::Font::Key</a> &amp;&#160;</td>
          <td class="paramname"><em>p_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a pixel using a sharp edge outline method. </p>
<p>This function modifies the atlas data to apply a sharp edged outline around characters. The outline is formed by filling the entire area around the origin pixel, covering every pixel in a square of dimensions <code>outlineSize * 2</code> by <code>outlineSize * 2</code> centered around the origin.</p>
<p>Pixels in this area will be modified based on their distance from the origin pixel to give the appearance of a sharp edge. The outline's depth and spread are determined by the outline size specified in the font key.</p>
<dl class="section note"><dt>Note</dt><dd>This approach is similar to the Pixelized outline type but creates a more uniformly sharp appearance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_atlasData</td><td>The atlas data where pixels are stored. </td></tr>
    <tr><td class="paramname">p_atlasSize</td><td>The dimensions of the atlas. </td></tr>
    <tr><td class="paramname">p_pixelOrigin</td><td>The origin of the pixel (usually its top-left corner). </td></tr>
    <tr><td class="paramname">p_x</td><td>The x-coordinate of the current pixel. </td></tr>
    <tr><td class="paramname">p_y</td><td>The y-coordinate of the current pixel. </td></tr>
    <tr><td class="paramname">p_key</td><td><a class="el" href="classspk_1_1Font.html" title="Represents a font, which can be used for rendering text.">Font</a> key containing information like outline size, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16ab4a329dcbffca5372afe326dcee8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ab4a329dcbffca5372afe326dcee8a">&#9670;&nbsp;</a></span>_placePixelStandard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::_placePixelStandard </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_atlasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_atlasSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#a81b9738cf9ec67888207021519d1a673">spk::Vector2Int</a> &amp;&#160;</td>
          <td class="paramname"><em>p_pixelOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>p_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>p_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1Font_1_1Key.html">spk::Font::Key</a> &amp;&#160;</td>
          <td class="paramname"><em>p_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a pixel using the standard method to create a "circle" shape outline. </p>
<p>This function modifies the atlas data to apply a circular outline around characters. The outline shape is based on the indices within the font key. For each of these indices, if the corresponding pixel in the atlas data is marked as empty, it gets filled with a specific value (0x7F).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_atlasData</td><td>The atlas data where pixels are stored. </td></tr>
    <tr><td class="paramname">p_atlasSize</td><td>The dimensions of the atlas. </td></tr>
    <tr><td class="paramname">p_pixelOrigin</td><td>The origin of the pixel. </td></tr>
    <tr><td class="paramname">p_x</td><td>The x-coordinate of the current pixel. </td></tr>
    <tr><td class="paramname">p_y</td><td>The y-coordinate of the current pixel. </td></tr>
    <tr><td class="paramname">p_key</td><td><a class="el" href="classspk_1_1Font.html" title="Represents a font, which can be used for rendering text.">Font</a> key containing indices for the circular outline. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad46118152ba4567548dc43b532ffab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46118152ba4567548dc43b532ffab28">&#9670;&nbsp;</a></span>_requestPlacePixelFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacespk.html#ab63d6b521e49d6b38ad1a1ad57e337a1">PlacePixelFunction</a> spk::_requestPlacePixelFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1Font.html#ad6aea176b2688e771c0b34525a12bdc8">spk::Font::OutlineType</a> &amp;&#160;</td>
          <td class="paramname"><em>p_outlineType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests the appropriate pixel placement function based on outline type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_outlineType</td><td>The type of outline. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The appropriate pixel placement function. </dd></dl>

</div>
</div>
<a id="a4db08bac60928ed2e27eb9d9f0975591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db08bac60928ed2e27eb9d9f0975591">&#9670;&nbsp;</a></span>checkOpengl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::checkOpengl </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks for OpenGL errors and logs them along with a provided message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message to log along with any OpenGL errors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefd0e04975ab0187d20665ab8a864158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd0e04975ab0187d20665ab8a864158">&#9670;&nbsp;</a></span>className() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::className </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prettyFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the class name from the provided pretty function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prettyFunction</td><td>The pretty function string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted class name. </dd></dl>

</div>
</div>
<a id="abfcc5509d013801fd4d0ccf7c64cd83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcc5509d013801fd4d0ccf7c64cd83e">&#9670;&nbsp;</a></span>className() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::className </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>prettyFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the class name from the provided wide string pretty function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prettyFunction</td><td>The wide string pretty function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted class name. </dd></dl>

</div>
</div>
<a id="a1fbffd7fee4d12e48cbc514119c29092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbffd7fee4d12e48cbc514119c29092">&#9670;&nbsp;</a></span>compileProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::compileProgram </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>p_programID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>p_vertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>p_fragmentID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>X bytes in 1 blocks are possibly lost</p>
<p>X bytes in 1 blocks are possibly lost</p>

</div>
</div>
<a id="aa75635745fccbb641f55a9c9fcaa9829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75635745fccbb641f55a9c9fcaa9829">&#9670;&nbsp;</a></span>compileShaderModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::compileShaderModule </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>p_shaderIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>p_shaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>p_shaderCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>X bytes in 1 blocks are possibly lost</p>

</div>
</div>
<a id="a7d37acf3a4bdcd511bd06ceec8687ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d37acf3a4bdcd511bd06ceec8687ff3">&#9670;&nbsp;</a></span>convertCodeToOpenGL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spk::convertCodeToOpenGL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1ShaderLayout.html">spk::ShaderLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>p_shaderLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>p_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts shader code from Vulkan to OpenGL by replacing specific layout qualifiers. </p>
<p>Specifically, this function replaces the Vulkan-specific <code>layout(push_constant)</code> qualifier with the OpenGL-compatible <code>layout(binding = n)</code> qualifier, where <code>n</code> is the first available binding slot in the provided <a class="el" href="classspk_1_1ShaderLayout.html" title="Handles the layout of a Shader, including its different modules and layouts for various buffer types.">ShaderLayout</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_shaderLayout</td><td>The <a class="el" href="classspk_1_1ShaderLayout.html" title="Handles the layout of a Shader, including its different modules and layouts for various buffer types.">ShaderLayout</a> used to find the first available binding slot. </td></tr>
    <tr><td class="paramname">p_code</td><td>The original Vulkan shader code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Modified shader code that is OpenGL compatible. </dd></dl>

</div>
</div>
<a id="afd5d866254b21d59e02bb19bbacbe783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5d866254b21d59e02bb19bbacbe783">&#9670;&nbsp;</a></span>degreeToRadian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float spk::degreeToRadian </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>The angle in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The angle in radians. </dd></dl>

</div>
</div>
<a id="accca98d92e095c0e4bac94f5c8bad561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accca98d92e095c0e4bac94f5c8bad561">&#9670;&nbsp;</a></span>findFirstBindingAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spk::findFirstBindingAvailable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1ShaderLayout.html">spk::ShaderLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>p_shaderLayout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first available binding slot for a UniformBlock in a given <a class="el" href="classspk_1_1ShaderLayout.html" title="Handles the layout of a Shader, including its different modules and layouts for various buffer types.">ShaderLayout</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_shaderLayout</td><td>The <a class="el" href="classspk_1_1ShaderLayout.html" title="Handles the layout of a Shader, including its different modules and layouts for various buffer types.">ShaderLayout</a> to search within. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first available binding slot. </dd></dl>

</div>
</div>
<a id="af1da86df753aa08c134375767f1fd4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1da86df753aa08c134375767f1fd4b1">&#9670;&nbsp;</a></span>getChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t spk::getChar </td>
          <td>(</td>
          <td class="paramtype">std::wfstream &amp;&#160;</td>
          <td class="paramname"><em>p_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a wide character from the provided wide file stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_file</td><td>The wide file stream to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The readed wide character. </dd></dl>

</div>
</div>
<a id="a88cef1352a23500e75882be52c79c066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cef1352a23500e75882be52c79c066">&#9670;&nbsp;</a></span>getCodepointsInFont()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;wchar_t&gt; spk::getCodepointsInFont </td>
          <td>(</td>
          <td class="paramtype">const stbtt_fontinfo *&#160;</td>
          <td class="paramname"><em>p_fontInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the codepoints present in the font. </p>
<p>Iterates through the range of valid wchar_t values and identifies which ones have valid glyphs in the given font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_fontInfo</td><td>Pointer to the font information structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the valid codepoints for the font. </dd></dl>

</div>
</div>
<a id="aa7fdff4cd71a5dfab09ff2f026a20d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fdff4cd71a5dfab09ff2f026a20d97">&#9670;&nbsp;</a></span>getFileContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::getFileContent </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>p_filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the content of a file and returns it as a std::wstring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_filePath</td><td>Path to the file that should be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The content of the file as a std::wstring. </dd></dl>

</div>
</div>
<a id="a8e2d076fc9d7a0ac86f30d5b9fb0c8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2d076fc9d7a0ac86f30d5b9fb0c8db">&#9670;&nbsp;</a></span>getFileContentAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spk::getFileContentAsString </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>p_filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the content of a file and returns it as a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_filePath</td><td>Path to the file that should be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The content of the file as a std::string. </dd></dl>

</div>
</div>
<a id="ae9f2918180da54f142029f041b9d1fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f2918180da54f142029f041b9d1fa3">&#9670;&nbsp;</a></span>getStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::getStr </td>
          <td>(</td>
          <td class="paramtype">std::wfstream &amp;&#160;</td>
          <td class="paramname"><em>p_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a wide string from the provided wide file stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_file</td><td>The wide file stream to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The readed wide string. </dd></dl>

</div>
</div>
<a id="a1254ad34752aba2c1362dedb3b3c2175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1254ad34752aba2c1362dedb3b3c2175">&#9670;&nbsp;</a></span>getStringSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::wstring &gt; spk::getStringSplit </td>
          <td>(</td>
          <td class="paramtype">std::wfstream &amp;&#160;</td>
          <td class="paramname"><em>p_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>p_expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and splits a wide string from the provided wide file stream based on the delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_file</td><td>The wide file stream to read from. </td></tr>
    <tr><td class="paramname">p_delim</td><td>The delimiter to split the string. </td></tr>
    <tr><td class="paramname">p_expectedSize</td><td>The expected size of the resulting vector. Default is -1, indicating no specific size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of substrings after splitting. </dd></dl>

</div>
</div>
<a id="acf34a729deb44804d107aef9d2aaad5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf34a729deb44804d107aef9d2aaad5c">&#9670;&nbsp;</a></span>listDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::wstring &gt; spk::listDir </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists all directories in the specified directory path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_path</td><td>The directory path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of directory names. </dd></dl>

</div>
</div>
<a id="a7fcd8e63bed947649a6876dc58f2b51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcd8e63bed947649a6876dc58f2b51c">&#9670;&nbsp;</a></span>listFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::wstring &gt; spk::listFile </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_extension</em> = <code>L&quot;*&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists all files in the specified directory path with the provided extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_path</td><td>The directory path. </td></tr>
    <tr><td class="paramname">p_extension</td><td>The file extension to filter files. Default is "*" (matches all files). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of file names. </dd></dl>

</div>
</div>
<a id="a42089d77d552f96126d09785e491a5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42089d77d552f96126d09785e491a5e6">&#9670;&nbsp;</a></span>MessageOpenGLCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GLAPIENTRY spk::MessageOpenGLCallback </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>p_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>p_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>p_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>p_severity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>p_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLchar *&#160;</td>
          <td class="paramname"><em>p_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p_userParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenGL debug callback function to handle and log runtime messages. </p>
<p>This function is invoked by the OpenGL runtime to report errors, warnings, or other diagnostic messages. It filters messages based on severity and logs them to the standard error stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_source</td><td>The source of the debug message. </td></tr>
    <tr><td class="paramname">p_type</td><td>The type of the debug message. </td></tr>
    <tr><td class="paramname">p_id</td><td>The ID of the message. </td></tr>
    <tr><td class="paramname">p_severity</td><td>The severity level of the message. </td></tr>
    <tr><td class="paramname">p_length</td><td>The length of the message string. </td></tr>
    <tr><td class="paramname">p_message</td><td>The actual debug message string. </td></tr>
    <tr><td class="paramname">p_userParam</td><td>A user-defined parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bfb867af25d965b131886fe857d23d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfb867af25d965b131886fe857d23d4">&#9670;&nbsp;</a></span>methodName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::methodName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prettyFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the method name from the provided pretty function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prettyFunction</td><td>The pretty function string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted method name. </dd></dl>

</div>
</div>
<a id="a7220789e458bf250bb05472cd28acc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7220789e458bf250bb05472cd28acc6b">&#9670;&nbsp;</a></span>methodName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::methodName </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>prettyFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the method name from the provided wide string pretty function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prettyFunction</td><td>The wide string pretty function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted method name. </dd></dl>

</div>
</div>
<a id="a8cd3e0a18ce342e7152da660662a371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd3e0a18ce342e7152da660662a371d">&#9670;&nbsp;</a></span>numberLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned short spk::numberLength </td>
          <td>(</td>
          <td class="paramtype">NumericType&#160;</td>
          <td class="paramname"><em>p_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the length of a numeric value in a specified base. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumericType</td><td>The type of the numeric value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_number</td><td>The numeric value. </td></tr>
    <tr><td class="paramname">base</td><td>The base in which to calculate the length. Default is 10. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the numeric value. </dd></dl>

</div>
</div>
<a id="adc4d3ecda52ee833bc55ca7ece2f940e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4d3ecda52ee833bc55ca7ece2f940e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; spk::operator* </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the multiplication operator for an arithmetic value and a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the elements of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the arithmetic value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The arithmetic value to be added. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to which the arithmetic value is added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector resulting from the addition. </dd></dl>

</div>
</div>
<a id="a4f95f63066ab643b13ad27871d3a0aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f95f63066ab643b13ad27871d3a0aca">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt;TType&gt; spk::operator* </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded multiplication operator to multiply a value with a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The value to be multiplied. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to multiply the value with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of multiplying the value with the vector. </dd></dl>

</div>
</div>
<a id="ad6c500689e1936587d90db1f1328ceb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c500689e1936587d90db1f1328ceb4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; spk::operator+ </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the addition operator for an arithmetic value and a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the elements of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the arithmetic value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The arithmetic value to be added. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to which the arithmetic value is added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector resulting from the addition. </dd></dl>

</div>
</div>
<a id="a8581e17fe52f716d72b87d12669f7620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8581e17fe52f716d72b87d12669f7620">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt;TType&gt; spk::operator+ </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded addition operator to add a value to a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The value to be added. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to add the value to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of adding the value to the vector. </dd></dl>

</div>
</div>
<a id="a443c70714a630e0cbc2199d56b92cc03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443c70714a630e0cbc2199d56b92cc03">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; spk::operator- </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the substraction operator for an arithmetic value and a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the elements of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the arithmetic value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The arithmetic value to be added. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to which the arithmetic value is added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector resulting from the addition. </dd></dl>

</div>
</div>
<a id="a70753e5aacb8a5eb2f6ae254c139e44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70753e5aacb8a5eb2f6ae254c139e44c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt;TType&gt; spk::operator- </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded subtraction operator to subtract a value from a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The value to be subtracted. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to subtract the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of subtracting the value from the vector. </dd></dl>

</div>
</div>
<a id="a4a8a9957f5dff3695f49beb037108568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8a9957f5dff3695f49beb037108568">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt;TType&gt; spk::operator/ </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the division operator for an arithmetic value and a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the elements of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the arithmetic value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The arithmetic value to be added. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to which the arithmetic value is added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector resulting from the addition. </dd></dl>

</div>
</div>
<a id="abc9fb6d5f31677ea83f5e5d3d44c6ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9fb6d5f31677ea83f5e5d3d44c6ed2">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType , typename TValueType , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;TValueType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt;TType&gt; spk::operator/ </td>
          <td>(</td>
          <td class="paramtype">TValueType&#160;</td>
          <td class="paramname"><em>p_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded division operator to divide a value by a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
    <tr><td class="paramname">TValueType</td><td>The type of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>The value to be divided. </td></tr>
    <tr><td class="paramname">p_point</td><td>The vector to divide the value by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of dividing the value by the vector. </dd></dl>

</div>
</div>
<a id="a14952c18111b1dbd754b3609c923259f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14952c18111b1dbd754b3609c923259f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classspk_1_1AbstractTexture.html#a787fcde7373f2fc8ce0963ced09de4e2">AbstractTexture::Filtering</a> &amp;&#160;</td>
          <td class="paramname"><em>p_filtering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the insertion operator for <a class="el" href="classspk_1_1AbstractTexture.html#a787fcde7373f2fc8ce0963ced09de4e2" title="Texture filtering options. Defines the various filtering methods that can be applied when sampling th...">AbstractTexture::Filtering</a>. This allows printing of Filtering enum values to a wide output stream in a human-readable format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_os</td><td>Wide output stream to insert into. </td></tr>
    <tr><td class="paramname">p_filtering</td><td>Filtering enum value to be converted to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the modified output stream. </dd></dl>

</div>
</div>
<a id="a508ccf4cd36f6ce464d8b4016fdedb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508ccf4cd36f6ce464d8b4016fdedb9a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classspk_1_1AbstractTexture.html#a8668b8e9dc849296ba3d07aa641007a6">AbstractTexture::Format</a> &amp;&#160;</td>
          <td class="paramname"><em>p_format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the insertion operator for <a class="el" href="classspk_1_1AbstractTexture.html#a8668b8e9dc849296ba3d07aa641007a6" title="Texture formats. Defines the different color channels a texture can have.">AbstractTexture::Format</a>. This allows printing of Format enum values to a wide output stream in a human-readable format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_os</td><td>Wide output stream to insert into. </td></tr>
    <tr><td class="paramname">p_format</td><td>Format enum value to be converted to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the modified output stream. </dd></dl>

</div>
</div>
<a id="a3bcfc3bc2aba3f10502336996c4470cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcfc3bc2aba3f10502336996c4470cc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classspk_1_1AbstractTexture.html#a025d98644a7d454c27d865572014e031">AbstractTexture::Mipmap</a> &amp;&#160;</td>
          <td class="paramname"><em>p_mipmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the insertion operator for <a class="el" href="classspk_1_1AbstractTexture.html#a025d98644a7d454c27d865572014e031" title="Mipmap settings for textures. Defines whether mipmaps should be used for the texture.">AbstractTexture::Mipmap</a>. This allows printing of Mipmap enum values to a wide output stream in a human-readable format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_os</td><td>Wide output stream to insert into. </td></tr>
    <tr><td class="paramname">p_mipmap</td><td>Mipmap enum value to be converted to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the modified output stream. </dd></dl>

</div>
</div>
<a id="afc51ec58cbafb68ae53080379e035741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc51ec58cbafb68ae53080379e035741">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classspk_1_1AbstractTexture.html#a51404e7a46755485f8c548db2af49e1f">AbstractTexture::Wrap</a> &amp;&#160;</td>
          <td class="paramname"><em>p_wrap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the insertion operator for <a class="el" href="classspk_1_1AbstractTexture.html#a51404e7a46755485f8c548db2af49e1f" title="Texture wrapping modes. Defines how the texture behaves when sampled outside the [0,...">AbstractTexture::Wrap</a>. This allows printing of Wrap enum values to a wide output stream in a human-readable format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_os</td><td>Wide output stream to insert into. </td></tr>
    <tr><td class="paramname">p_wrap</td><td>Wrap enum value to be converted to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the modified output stream. </dd></dl>

</div>
</div>
<a id="aacba30e91fdc2a6f20d31e9fdbb6c059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacba30e91fdc2a6f20d31e9fdbb6c059">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>p_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">p_values</td><td>The color to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a id="a9599eec12355d40afbb699f241458cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9599eec12355d40afbb699f241458cd4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1ShaderModule_1_1Instruction.html#ad56deea84138da71568fd38db90b5d34">ShaderModule::Instruction::Type</a> &amp;&#160;</td>
          <td class="paramname"><em>p_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_os</td><td>The wide output stream where the formatted text will be written to. </td></tr>
    <tr><td class="paramname">p_type</td><td>The Instruction::Type object to be formatted and outputted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream. </dd></dl>

</div>
</div>
<a id="a2a5871b92a2419c920588de2f0449fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5871b92a2419c920588de2f0449fa6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classspk_1_1ShaderLayout.html">ShaderLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>p_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows for easy printing of <a class="el" href="classspk_1_1ShaderLayout.html" title="Handles the layout of a Shader, including its different modules and layouts for various buffer types.">ShaderLayout</a> objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_out</td><td>The wide output stream. </td></tr>
    <tr><td class="paramname">p_config</td><td>The <a class="el" href="classspk_1_1ShaderLayout.html" title="Handles the layout of a Shader, including its different modules and layouts for various buffer types.">ShaderLayout</a> object to insert into the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the modified wide output stream. </dd></dl>

</div>
</div>
<a id="a767f427d0bb2fa60e359bd675906da25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767f427d0bb2fa60e359bd675906da25">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1ShaderLayout_1_1Data.html">ShaderLayout::Data</a> &amp;&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_out</td><td>The output stream. </td></tr>
    <tr><td class="paramname">p_data</td><td>The Data struct to output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a id="a0af7677e8cb7ce3ffdce0ae61d53b1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af7677e8cb7ce3ffdce0ae61d53b1c1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1ShaderLayout_1_1Data.html#a5ca25000be7263653c0d234587ca1539">ShaderLayout::Data::Type</a> &amp;&#160;</td>
          <td class="paramname"><em>p_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_out</td><td>The output stream. </td></tr>
    <tr><td class="paramname">p_type</td><td>The data type to output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a id="abc569ea956f7ba847cf5560f1ebd810a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc569ea956f7ba847cf5560f1ebd810a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classspk_1_1ShaderLayout_1_1FieldArrayLayout.html">ShaderLayout::FieldArrayLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>p_layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_out</td><td>The output stream. </td></tr>
    <tr><td class="paramname">p_layout</td><td>The FieldArrayLayout to output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a id="a5cd33df9019cf4c85fab84cb702b30d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd33df9019cf4c85fab84cb702b30d6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspk_1_1ShaderLayout_1_1FieldArrayLayout_1_1Field.html">ShaderLayout::FieldArrayLayout::Field</a> &amp;&#160;</td>
          <td class="paramname"><em>p_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_out</td><td>The output stream. </td></tr>
    <tr><td class="paramname">p_field</td><td>The Field to output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a id="addb5801f7bcf70cc6b726033f9ff429c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb5801f7bcf70cc6b726033f9ff429c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classspk_1_1ShaderLayout_1_1PushConstantsLayout.html">ShaderLayout::PushConstantsLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>p_layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_out</td><td>The wide output stream where the formatted text will be written to. </td></tr>
    <tr><td class="paramname">p_layout</td><td>The PushConstantsLayout object to be formatted and outputted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream. </dd></dl>

</div>
</div>
<a id="a0da50a9ba3d3e85ca37ca8b78d0ce7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da50a9ba3d3e85ca37ca8b78d0ce7c0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; spk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classspk_1_1ShaderLayout_1_1StructureLayout.html">ShaderLayout::StructureLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>p_layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_out</td><td>The output stream. </td></tr>
    <tr><td class="paramname">p_layout</td><td>The StructureLayout to output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a id="a0f89235a75499ada62763e9d3b2dec82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f89235a75499ada62763e9d3b2dec82">&#9670;&nbsp;</a></span>positiveModulo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">intmax_t spk::positiveModulo </td>
          <td>(</td>
          <td class="paramtype">intmax_t&#160;</td>
          <td class="paramname"><em>p_integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intmax_t&#160;</td>
          <td class="paramname"><em>p_dividor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the positive modulo of the given integer and divisor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_integer</td><td>The integer value. </td></tr>
    <tr><td class="paramname">p_dividor</td><td>The divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The positive modulo result. </dd></dl>

</div>
</div>
<a id="aef69d819e47992e44a46c974ced8322c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef69d819e47992e44a46c974ced8322c">&#9670;&nbsp;</a></span>radianToDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float spk::radianToDegree </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radians</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts radians to degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radians</td><td>The angle in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The angle in degrees. </dd></dl>

</div>
</div>
<a id="a0c3f970e1658247b9ee9797f18727934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3f970e1658247b9ee9797f18727934">&#9670;&nbsp;</a></span>redirectException()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::redirectException </td>
          <td>(</td>
          <td class="paramtype">std::exception &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring *&#160;</td>
          <td class="paramname"><em>p_jobName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redirect an exception emitted by a thread during the execution of a job. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The orginal exception. </td></tr>
    <tr><td class="paramname">p_jobName</td><td>The name of the job who just thrown an exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e939c5f5ec45c7e93528a983b494a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e939c5f5ec45c7e93528a983b494a0d">&#9670;&nbsp;</a></span>stringSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::wstring &gt; spk::stringSplit </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the input wide string into a vector of substrings based on the provided delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_string</td><td>The input wide string to split. </td></tr>
    <tr><td class="paramname">p_delim</td><td>The delimiter to split the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of substrings after splitting. </dd></dl>

</div>
</div>
<a id="afd100e360a6ec28d27838bedd6167f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd100e360a6ec28d27838bedd6167f02">&#9670;&nbsp;</a></span>throwException()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spk::throwException </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_errorLine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws a runtime_error with the provided error message as wide string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_errorLine</td><td>The error message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b79166d0f6923f9730d6d359d9622b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b79166d0f6923f9730d6d359d9622b3">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const GLenum &amp;&#160;</td>
          <td class="paramname"><em>p_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a GLenum value to its corresponding wide string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_type</td><td>The GLenum value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wide string representation of the GLenum. </dd></dl>

</div>
</div>
<a id="a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bd1fa9ce6e3e0ed5fd7489fdf7a0ba">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacespk.html#aed6527896d34c2628aec65a369dee252">InputState</a> &amp;&#160;</td>
          <td class="paramname"><em>p_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an InputState value to a string. </p>
<p>This function returns a string representation of an InputState value. This can be useful for debugging or logging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_status</td><td>The InputState value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representation of the InputState value. </dd></dl>

</div>
</div>
<a id="aa420d958f7152d62c0f50b806c26a0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa420d958f7152d62c0f50b806c26a0ff">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector2.html">IVector2</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a vector to a wstring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_point</td><td>The vector to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting string. </dd></dl>

</div>
</div>
<a id="a49a7d505764b6392380bf9d30d007dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a7d505764b6392380bf9d30d007dba">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspk_1_1IVector3.html">IVector3</a>&lt; TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a vector to a wstring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_point</td><td>The vector to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting string. </dd></dl>

</div>
</div>
<a id="a98695e9de44684d6aaecc705564cd6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98695e9de44684d6aaecc705564cd6d8">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::wstring &amp; spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28">Keyboard::Key</a> &amp;&#160;</td>
          <td class="paramname"><em>p_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28" title="Enum for representing keyboard keys.">Keyboard::Key</a> to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_key</td><td>The <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28" title="Enum for representing keyboard keys.">Keyboard::Key</a> to convert to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the <a class="el" href="classspk_1_1Keyboard.html#a13a0bee8478b4e4e8162d4f389134b28" title="Enum for representing keyboard keys.">Keyboard::Key</a>. </dd></dl>

</div>
</div>
<a id="a8b0d135246aecf232855d7d804bb55bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0d135246aecf232855d7d804bb55bd">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5">Mouse::Button</a> &amp;&#160;</td>
          <td class="paramname"><em>p_button</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5" title="Enum for mouse buttons.">Mouse::Button</a> value to a wstring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_button</td><td>The <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5" title="Enum for mouse buttons.">Mouse::Button</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted <a class="el" href="classspk_1_1Mouse.html#a7e51467586bf8952f05461cc3b9fd5b5" title="Enum for mouse buttons.">Mouse::Button</a> value. </dd></dl>

</div>
</div>
<a id="a542066c55ed7a3bca5a973af1e8bf8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542066c55ed7a3bca5a973af1e8bf8cd">&#9670;&nbsp;</a></span>to_wstring() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1IPerlin.html#a3266c3dd973db71cfd0f81a6b8ff4540">spk::IPerlin::Interpolation</a> &amp;&#160;</td>
          <td class="paramname"><em>p_interpolation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an Interpolation type to a string representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_interpolation</td><td>Interpolation type to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representation of the Interpolation type. </dd></dl>

</div>
</div>
<a id="aa050ad5cd7dd01953b53b0d775890f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa050ad5cd7dd01953b53b0d775890f0e">&#9670;&nbsp;</a></span>toOpenGLFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint spk::toOpenGLFiltering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1AbstractTexture.html#a787fcde7373f2fc8ce0963ced09de4e2">AbstractTexture::Filtering</a> &amp;&#160;</td>
          <td class="paramname"><em>p_filtering</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Sparkle texture filtering type to its equivalent OpenGL filtering type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_filtering</td><td>The Sparkle texture filtering type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent OpenGL texture filtering type. </dd></dl>

</div>
</div>
<a id="a393c9bb05e2e511f137bbd97f7b1da06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393c9bb05e2e511f137bbd97f7b1da06">&#9670;&nbsp;</a></span>toOpenGLFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum spk::toOpenGLFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1AbstractTexture.html#a8668b8e9dc849296ba3d07aa641007a6">AbstractTexture::Format</a> &amp;&#160;</td>
          <td class="paramname"><em>p_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Sparkle texture format to its equivalent OpenGL format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_format</td><td>The Sparkle texture format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent OpenGL texture format. </dd></dl>

</div>
</div>
<a id="a0b3397242821cdec550b7e33af76623f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3397242821cdec550b7e33af76623f">&#9670;&nbsp;</a></span>toOpenGLWrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint spk::toOpenGLWrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspk_1_1AbstractTexture.html#a51404e7a46755485f8c548db2af49e1f">AbstractTexture::Wrap</a> &amp;&#160;</td>
          <td class="paramname"><em>p_wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Sparkle texture wrapping mode to its equivalent OpenGL wrapping mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_wrap</td><td>The Sparkle texture wrapping mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent OpenGL texture wrapping mode. </dd></dl>

</div>
</div>
<a id="a736875e1ee6b20eb1e2dd997ba8d354e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736875e1ee6b20eb1e2dd997ba8d354e">&#9670;&nbsp;</a></span>universalCodeDecoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring spk::universalCodeDecoder </td>
          <td>(</td>
          <td class="paramtype">const wchar_t &amp;&#160;</td>
          <td class="paramname"><em>p_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns a non printable or unicode character into its universal code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_code</td><td>A non printable or unicode character. ]0-31[ or ]127-0x10FFFF[ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::wstring A string containing the universal code of the character. (\uXXXX or \uXXXX\uXXXX respectively for 8 or 16 bit characters) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the character is in range ]32-126[, it is returned as is. If the character code is higher than 0x10FFFF, an empty string is returned. </dd></dl>

</div>
</div>
<a id="a6848012087aaf1cc22b17362bd495af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6848012087aaf1cc22b17362bd495af5">&#9670;&nbsp;</a></span>universalCodeEncoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t spk::universalCodeEncoder </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns a universal code into a non printable or unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_code</td><td>The wstring containing the universal code of the character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>wchar_t A non printable or unicode character. ]0-31[ or ]127-0x10FFFF[ </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If your local does not support UTF16, you should use try/catch if you plan to convert or print the result. </dd></dl>

</div>
</div>
<a id="a35c88ea124c5bf25cfd51823d719a92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c88ea124c5bf25cfd51823d719a92b">&#9670;&nbsp;</a></span>WindowProc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LRESULT CALLBACK spk::WindowProc </td>
          <td>(</td>
          <td class="paramtype">HWND&#160;</td>
          <td class="paramname"><em>p_hwnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>p_uMsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WPARAM&#160;</td>
          <td class="paramname"><em>p_wParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPARAM&#160;</td>
          <td class="paramname"><em>p_lParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes messages sent to a window. </p>
<p>Forward declaration of <a class="el" href="classspk_1_1Window.html">Window</a> Procedure function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_hwnd</td><td>Handle to the window. </td></tr>
    <tr><td class="paramname">p_uMsg</td><td>The message. </td></tr>
    <tr><td class="paramname">p_wParam</td><td>Additional message-specific information. </td></tr>
    <tr><td class="paramname">p_lParam</td><td>Additional message-specific information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the message processing and depends on the message sent. </dd></dl>

</div>
</div>
<a id="af968ab2db5e30a212aa373cddf7016d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af968ab2db5e30a212aa373cddf7016d5">&#9670;&nbsp;</a></span>wstringToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string spk::wstringToString </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>p_wstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a wide string to a standard string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_wstr</td><td>The wide string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted standard string. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
