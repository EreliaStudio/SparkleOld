<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparkle: spk::DataBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sparkle
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacespk.html">spk</a></li><li class="navelem"><a class="el" href="classspk_1_1DataBuffer.html">DataBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classspk_1_1DataBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">spk::DataBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for managing data buffers.  
 <a href="classspk_1_1DataBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="spk__data__buffer_8hpp_source.html">spk_data_buffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a716866b679b1a1b6d7046a5bb65347ec"><td class="memItemLeft" align="right" valign="top"><a id="a716866b679b1a1b6d7046a5bb65347ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#a716866b679b1a1b6d7046a5bb65347ec">DataBuffer</a> ()</td></tr>
<tr class="memdesc:a716866b679b1a1b6d7046a5bb65347ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for the <a class="el" href="classspk_1_1DataBuffer.html" title="Class for managing data buffers.">DataBuffer</a> class. <br /></td></tr>
<tr class="separator:a716866b679b1a1b6d7046a5bb65347ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e3ef2003ed2b5598b5eb3c7c807e72"><td class="memItemLeft" align="right" valign="top"><a id="a85e3ef2003ed2b5598b5eb3c7c807e72"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#a85e3ef2003ed2b5598b5eb3c7c807e72">DataBuffer</a> (size_t p_dataSize)</td></tr>
<tr class="memdesc:a85e3ef2003ed2b5598b5eb3c7c807e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with a pre-defined sized data buffer. <br /></td></tr>
<tr class="separator:a85e3ef2003ed2b5598b5eb3c7c807e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a73cc703c98ed3e4d679ece91685fe"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#aa7a73cc703c98ed3e4d679ece91685fe">data</a> ()</td></tr>
<tr class="memdesc:aa7a73cc703c98ed3e4d679ece91685fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the content of the <a class="el" href="classspk_1_1DataBuffer.html" title="Class for managing data buffers.">DataBuffer</a> as a raw bytes array.  <a href="classspk_1_1DataBuffer.html#aa7a73cc703c98ed3e4d679ece91685fe">More...</a><br /></td></tr>
<tr class="separator:aa7a73cc703c98ed3e4d679ece91685fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d549c5e944769cfd2cd042ee618b3a8"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#a1d549c5e944769cfd2cd042ee618b3a8">data</a> () const</td></tr>
<tr class="memdesc:a1d549c5e944769cfd2cd042ee618b3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the content of the <a class="el" href="classspk_1_1DataBuffer.html" title="Class for managing data buffers.">DataBuffer</a> as a const raw bytes array.  <a href="classspk_1_1DataBuffer.html#a1d549c5e944769cfd2cd042ee618b3a8">More...</a><br /></td></tr>
<tr class="separator:a1d549c5e944769cfd2cd042ee618b3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f13469e9040f9db9d7727cc4aa42778"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#a2f13469e9040f9db9d7727cc4aa42778">size</a> () const</td></tr>
<tr class="memdesc:a2f13469e9040f9db9d7727cc4aa42778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the buffer.  <a href="classspk_1_1DataBuffer.html#a2f13469e9040f9db9d7727cc4aa42778">More...</a><br /></td></tr>
<tr class="separator:a2f13469e9040f9db9d7727cc4aa42778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1441a1c3abc6a4f5c55a2a66798be379"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#a1441a1c3abc6a4f5c55a2a66798be379">bookmark</a> () const</td></tr>
<tr class="memdesc:a1441a1c3abc6a4f5c55a2a66798be379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bookmark of the buffer.  <a href="classspk_1_1DataBuffer.html#a1441a1c3abc6a4f5c55a2a66798be379">More...</a><br /></td></tr>
<tr class="separator:a1441a1c3abc6a4f5c55a2a66798be379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f1ec65d939c18bacbc61abe59e1064"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#aa7f1ec65d939c18bacbc61abe59e1064">leftover</a> () const</td></tr>
<tr class="memdesc:aa7f1ec65d939c18bacbc61abe59e1064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the remaining buffer.  <a href="classspk_1_1DataBuffer.html#aa7f1ec65d939c18bacbc61abe59e1064">More...</a><br /></td></tr>
<tr class="separator:aa7f1ec65d939c18bacbc61abe59e1064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a4f828b5314bfefd2cbff9bd31e42e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#a95a4f828b5314bfefd2cbff9bd31e42e">empty</a> () const</td></tr>
<tr class="memdesc:a95a4f828b5314bfefd2cbff9bd31e42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the buffer is empty.  <a href="classspk_1_1DataBuffer.html#a95a4f828b5314bfefd2cbff9bd31e42e">More...</a><br /></td></tr>
<tr class="separator:a95a4f828b5314bfefd2cbff9bd31e42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b4150f9dd7ad36759c60e4ed1f82f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#ab0b4150f9dd7ad36759c60e4ed1f82f6">resize</a> (const size_t &amp;p_newSize)</td></tr>
<tr class="memdesc:ab0b4150f9dd7ad36759c60e4ed1f82f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the amount of data requested.  <a href="classspk_1_1DataBuffer.html#ab0b4150f9dd7ad36759c60e4ed1f82f6">More...</a><br /></td></tr>
<tr class="separator:ab0b4150f9dd7ad36759c60e4ed1f82f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf468b222ec2331008c51c4e9ae7a35a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#adf468b222ec2331008c51c4e9ae7a35a">skip</a> (const size_t &amp;p_number)</td></tr>
<tr class="memdesc:adf468b222ec2331008c51c4e9ae7a35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the bookmark ahead by the specified number.  <a href="classspk_1_1DataBuffer.html#adf468b222ec2331008c51c4e9ae7a35a">More...</a><br /></td></tr>
<tr class="separator:adf468b222ec2331008c51c4e9ae7a35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eefec4799fb6b9d6251cca86ebfa04"><td class="memItemLeft" align="right" valign="top"><a id="ad4eefec4799fb6b9d6251cca86ebfa04"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#ad4eefec4799fb6b9d6251cca86ebfa04">clear</a> ()</td></tr>
<tr class="memdesc:ad4eefec4799fb6b9d6251cca86ebfa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the buffer and reset the bookmark. <br /></td></tr>
<tr class="separator:ad4eefec4799fb6b9d6251cca86ebfa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea4655da477844008708b1283c83e75"><td class="memItemLeft" align="right" valign="top"><a id="a0ea4655da477844008708b1283c83e75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#a0ea4655da477844008708b1283c83e75">reset</a> ()</td></tr>
<tr class="memdesc:a0ea4655da477844008708b1283c83e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the bookmark to the start of the buffer. <br /></td></tr>
<tr class="separator:a0ea4655da477844008708b1283c83e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62775fb5a5cc3ef25dd87d41976b978f"><td class="memTemplParams" colspan="2">template&lt;typename OutputType &gt; </td></tr>
<tr class="memitem:a62775fb5a5cc3ef25dd87d41976b978f"><td class="memTemplItemLeft" align="right" valign="top">OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#a62775fb5a5cc3ef25dd87d41976b978f">get</a> () const</td></tr>
<tr class="memdesc:a62775fb5a5cc3ef25dd87d41976b978f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve data of a specific type from the buffer.  <a href="classspk_1_1DataBuffer.html#a62775fb5a5cc3ef25dd87d41976b978f">More...</a><br /></td></tr>
<tr class="separator:a62775fb5a5cc3ef25dd87d41976b978f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90c23dd9a031995ecb8f28ded1251b7"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:ac90c23dd9a031995ecb8f28ded1251b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#ac90c23dd9a031995ecb8f28ded1251b7">edit</a> (const size_t &amp;p_offset, const InputType &amp;p_input)</td></tr>
<tr class="memdesc:ac90c23dd9a031995ecb8f28ded1251b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit the buffer at a specific offset with input data.  <a href="classspk_1_1DataBuffer.html#ac90c23dd9a031995ecb8f28ded1251b7">More...</a><br /></td></tr>
<tr class="separator:ac90c23dd9a031995ecb8f28ded1251b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c08e910637dc3808dd0870c9223788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#a02c08e910637dc3808dd0870c9223788">edit</a> (const size_t &amp;p_offset, const void *p_data, const size_t &amp;p_dataSize)</td></tr>
<tr class="memdesc:a02c08e910637dc3808dd0870c9223788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edits a portion of the data buffer starting at a specified offset.  <a href="classspk_1_1DataBuffer.html#a02c08e910637dc3808dd0870c9223788">More...</a><br /></td></tr>
<tr class="separator:a02c08e910637dc3808dd0870c9223788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf549d489c5f326e781e4408d550e7e0"><td class="memTemplParams" colspan="2">template&lt;typename InputType , typename std::enable_if_t&lt;!spk::IsContainer&lt; InputType &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adf549d489c5f326e781e4408d550e7e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspk_1_1DataBuffer.html">DataBuffer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#adf549d489c5f326e781e4408d550e7e0">operator&lt;&lt;</a> (const InputType &amp;p_input)</td></tr>
<tr class="memdesc:adf549d489c5f326e781e4408d550e7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the buffer.  <a href="classspk_1_1DataBuffer.html#adf549d489c5f326e781e4408d550e7e0">More...</a><br /></td></tr>
<tr class="separator:adf549d489c5f326e781e4408d550e7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94fe4daf3b1d0a9720ea9e19394915b"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , typename std::enable_if_t&lt;!spk::IsContainer&lt; OutputType &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af94fe4daf3b1d0a9720ea9e19394915b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classspk_1_1DataBuffer.html">DataBuffer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#af94fe4daf3b1d0a9720ea9e19394915b">operator&gt;&gt;</a> (OutputType &amp;p_output) const</td></tr>
<tr class="memdesc:af94fe4daf3b1d0a9720ea9e19394915b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract data from the buffer.  <a href="classspk_1_1DataBuffer.html#af94fe4daf3b1d0a9720ea9e19394915b">More...</a><br /></td></tr>
<tr class="separator:af94fe4daf3b1d0a9720ea9e19394915b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf549d489c5f326e781e4408d550e7e0"><td class="memTemplParams" colspan="2">template&lt;typename InputType , typename std::enable_if_t&lt; spk::IsContainer&lt; InputType &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adf549d489c5f326e781e4408d550e7e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspk_1_1DataBuffer.html">DataBuffer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#adf549d489c5f326e781e4408d550e7e0">operator&lt;&lt;</a> (const InputType &amp;p_input)</td></tr>
<tr class="memdesc:adf549d489c5f326e781e4408d550e7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert container data into the buffer.  <a href="classspk_1_1DataBuffer.html#adf549d489c5f326e781e4408d550e7e0">More...</a><br /></td></tr>
<tr class="separator:adf549d489c5f326e781e4408d550e7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94fe4daf3b1d0a9720ea9e19394915b"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , typename std::enable_if_t&lt; spk::IsContainer&lt; OutputType &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af94fe4daf3b1d0a9720ea9e19394915b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classspk_1_1DataBuffer.html">DataBuffer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#af94fe4daf3b1d0a9720ea9e19394915b">operator&gt;&gt;</a> (OutputType &amp;p_output) const</td></tr>
<tr class="memdesc:af94fe4daf3b1d0a9720ea9e19394915b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract container data from the buffer.  <a href="classspk_1_1DataBuffer.html#af94fe4daf3b1d0a9720ea9e19394915b">More...</a><br /></td></tr>
<tr class="separator:af94fe4daf3b1d0a9720ea9e19394915b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3800f8eceaa598549a52dcf4aab300e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspk_1_1DataBuffer.html#ad3800f8eceaa598549a52dcf4aab300e">append</a> (const void *p_data, const size_t &amp;p_dataSize)</td></tr>
<tr class="memdesc:ad3800f8eceaa598549a52dcf4aab300e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends data to the end of the existing internal buffer.  <a href="classspk_1_1DataBuffer.html#ad3800f8eceaa598549a52dcf4aab300e">More...</a><br /></td></tr>
<tr class="separator:ad3800f8eceaa598549a52dcf4aab300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for managing data buffers. </p>
<p>This class is designed to provide convenient and efficient storage and retrieval of data. It supports various data types including standard and container types, provided they are standard layout types.</p>
<p>The class provides a set of utility methods and operator overloads for reading from and</p>
<p>writing to the buffer, as well as for managing the internal state of the buffer. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad3800f8eceaa598549a52dcf4aab300e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3800f8eceaa598549a52dcf4aab300e">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spk::DataBuffer::append </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>p_dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends data to the end of the existing internal buffer. </p>
<p>This function enlarges the internal data buffer by the size of the new data to be added. It then copies the new data into the buffer, starting at the point where the old data ends.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_data</td><td>Pointer to the source data to append. </td></tr>
    <tr><td class="paramname">p_dataSize</td><td>The size of the data to append, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1441a1c3abc6a4f5c55a2a66798be379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1441a1c3abc6a4f5c55a2a66798be379">&#9670;&nbsp;</a></span>bookmark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t spk::DataBuffer::bookmark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bookmark of the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The position of the bookmark. </dd></dl>

</div>
</div>
<a id="aa7a73cc703c98ed3e4d679ece91685fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a73cc703c98ed3e4d679ece91685fe">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* spk::DataBuffer::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the content of the <a class="el" href="classspk_1_1DataBuffer.html" title="Class for managing data buffers.">DataBuffer</a> as a raw bytes array. </p>
<dl class="section return"><dt>Returns</dt><dd>The content of the <a class="el" href="classspk_1_1DataBuffer.html" title="Class for managing data buffers.">DataBuffer</a> as raw bytes </dd></dl>

</div>
</div>
<a id="a1d549c5e944769cfd2cd042ee618b3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d549c5e944769cfd2cd042ee618b3a8">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* spk::DataBuffer::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the content of the <a class="el" href="classspk_1_1DataBuffer.html" title="Class for managing data buffers.">DataBuffer</a> as a const raw bytes array. </p>
<dl class="section return"><dt>Returns</dt><dd>The content of the <a class="el" href="classspk_1_1DataBuffer.html" title="Class for managing data buffers.">DataBuffer</a> as const raw bytes </dd></dl>

</div>
</div>
<a id="ac90c23dd9a031995ecb8f28ded1251b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90c23dd9a031995ecb8f28ded1251b7">&#9670;&nbsp;</a></span>edit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spk::DataBuffer::edit </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>p_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputType &amp;&#160;</td>
          <td class="paramname"><em>p_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Edit the buffer at a specific offset with input data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputType</td><td>The type of input data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_offset</td><td>Offset in the buffer where the data should be written. </td></tr>
    <tr><td class="paramname">p_input</td><td>The data to write into the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c08e910637dc3808dd0870c9223788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c08e910637dc3808dd0870c9223788">&#9670;&nbsp;</a></span>edit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spk::DataBuffer::edit </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>p_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>p_dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Edits a portion of the data buffer starting at a specified offset. </p>
<p>This function copies data from the source to the internal data buffer, starting at a given offset. The size of the data to copy is also specified. If the sum of the offset and data size exceeds the size of the internal buffer, a runtime error is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_offset</td><td>The starting offset in the internal data buffer. </td></tr>
    <tr><td class="paramname">p_data</td><td>The pointer to the source data to copy. </td></tr>
    <tr><td class="paramname">p_dataSize</td><td>The size of the data to copy, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the sum of p_offset and p_dataSize exceeds the internal buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95a4f828b5314bfefd2cbff9bd31e42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a4f828b5314bfefd2cbff9bd31e42e">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool spk::DataBuffer::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the buffer is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there's no leftover data in the buffer, false otherwise. </dd></dl>

</div>
</div>
<a id="a62775fb5a5cc3ef25dd87d41976b978f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62775fb5a5cc3ef25dd87d41976b978f">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputType spk::DataBuffer::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve data of a specific type from the buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputType</td><td>The type of data to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The retrieved data. </dd></dl>

</div>
</div>
<a id="aa7f1ec65d939c18bacbc61abe59e1064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f1ec65d939c18bacbc61abe59e1064">&#9670;&nbsp;</a></span>leftover()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t spk::DataBuffer::leftover </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the remaining buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The size from the bookmark to the end of the buffer. </dd></dl>

</div>
</div>
<a id="adf549d489c5f326e781e4408d550e7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf549d489c5f326e781e4408d550e7e0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputType , typename std::enable_if_t&lt;!spk::IsContainer&lt; InputType &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspk_1_1DataBuffer.html">DataBuffer</a>&amp; spk::DataBuffer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const InputType &amp;&#160;</td>
          <td class="paramname"><em>p_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the buffer. </p>
<p>This template function handles all non-container types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputType</td><td>The type of input data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_input</td><td>The data to insert into the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the current <a class="el" href="classspk_1_1DataBuffer.html" title="Class for managing data buffers.">DataBuffer</a> object. </dd></dl>

</div>
</div>
<a id="adf549d489c5f326e781e4408d550e7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf549d489c5f326e781e4408d550e7e0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputType , typename std::enable_if_t&lt; spk::IsContainer&lt; InputType &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspk_1_1DataBuffer.html">DataBuffer</a>&amp; spk::DataBuffer::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const InputType &amp;&#160;</td>
          <td class="paramname"><em>p_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert container data into the buffer. </p>
<p>This template function handles all container types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputType</td><td>The type of input data (must be a container type). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_input</td><td>The container data to insert into the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the current <a class="el" href="classspk_1_1DataBuffer.html" title="Class for managing data buffers.">DataBuffer</a> object. </dd></dl>

</div>
</div>
<a id="af94fe4daf3b1d0a9720ea9e19394915b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94fe4daf3b1d0a9720ea9e19394915b">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , typename std::enable_if_t&lt;!spk::IsContainer&lt; OutputType &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspk_1_1DataBuffer.html">DataBuffer</a>&amp; spk::DataBuffer::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">OutputType &amp;&#160;</td>
          <td class="paramname"><em>p_output</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract data from the buffer. </p>
<p>This template function handles all non-container types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputType</td><td>The type of data to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_output</td><td>Reference to a variable where the extracted data should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the current <a class="el" href="classspk_1_1DataBuffer.html" title="Class for managing data buffers.">DataBuffer</a> object. </dd></dl>

</div>
</div>
<a id="af94fe4daf3b1d0a9720ea9e19394915b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94fe4daf3b1d0a9720ea9e19394915b">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , typename std::enable_if_t&lt; spk::IsContainer&lt; OutputType &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classspk_1_1DataBuffer.html">DataBuffer</a>&amp; spk::DataBuffer::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">OutputType &amp;&#160;</td>
          <td class="paramname"><em>p_output</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract container data from the buffer. </p>
<p>This template function handles all container types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputType</td><td>The type of data to extract (must be a container type). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_output</td><td>Reference to a variable where the extracted data should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the current <a class="el" href="classspk_1_1DataBuffer.html" title="Class for managing data buffers.">DataBuffer</a> object. </dd></dl>

</div>
</div>
<a id="ab0b4150f9dd7ad36759c60e4ed1f82f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b4150f9dd7ad36759c60e4ed1f82f6">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::DataBuffer::resize </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>p_newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the amount of data requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_newSize</td><td>The number of bytes required inside the content. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f13469e9040f9db9d7727cc4aa42778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f13469e9040f9db9d7727cc4aa42778">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t spk::DataBuffer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the buffer. </dd></dl>

</div>
</div>
<a id="adf468b222ec2331008c51c4e9ae7a35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf468b222ec2331008c51c4e9ae7a35a">&#9670;&nbsp;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spk::DataBuffer::skip </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>p_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the bookmark ahead by the specified number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_number</td><td>The number of bytes to skip. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Sparkle/includes/data_structure/<a class="el" href="spk__data__buffer_8hpp_source.html">spk_data_buffer.hpp</a></li>
<li>Sparkle/src/data_structure/spk_data_buffer.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
